/*
 * Copyright 2022 iLogtail Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#pragma once
#include <cstdint>
#include <json/json.h>
#include "config/Config.h"
#if defined(_MSC_VER)
#include <stddef.h>
#endif

extern "C" {
// The definition of Golang type is copied from PluginAdaptor.h that
// generated by `go build -buildmode=c-shared ...`.
#if defined(__linux__) || defined(__APPLE__) // *unix amd64
typedef long long GoInt64;
typedef GoInt64 GoInt;
typedef struct {
    const char* p;
    GoInt64 n;
} GoString;
typedef struct {
    void* data;
    GoInt len;
    GoInt cap;
} GoSlice;
#elif defined(_MSC_VER) // x86 Go + x86 MinGW + Win32 VS.
typedef long long GoInt64;
typedef int GoInt32;
typedef GoInt32 GoInt;
typedef struct {
    const char* p;
    ptrdiff_t n;
} _GoString_;
typedef _GoString_ GoString;
typedef struct {
    void* data;
    GoInt len;
    GoInt cap;
} GoSlice;
#endif

// Methods export by plugin.
typedef GoInt (*LoadGlobalConfigFun)(GoString);
typedef GoInt (*LoadConfigFun)(GoString p, GoString l, GoString c, GoInt64 k, GoString p2);
typedef GoInt (*UnloadConfigFun)(GoString p, GoString l, GoString c);
typedef GoInt (*ProcessRawLogFun)(GoString c, GoSlice l, GoString p, GoString t);
typedef GoInt (*ProcessRawLogV2Fun)(GoString c, GoSlice l, GoString p, GoString t, GoSlice tags);
typedef void (*HoldOnFun)(GoInt);
typedef void (*ResumeFun)();
typedef GoInt (*InitPluginBaseFun)();
typedef GoInt (*InitPluginBaseV2Fun)(GoString cfg);

// Methods export by adapter.
typedef int (*IsValidToSendFun)(long long logstoreKey);

typedef int (*SendPbFun)(const char* configName,
                         int configNameSize,
                         const char* logstore,
                         int logstoreSize,
                         char* pbBuffer,
                         int pbSize,
                         int lines);
typedef int (*SendPbV2Fun)(const char* configName,
                           int configNameSize,
                           const char* logstore,
                           int logstoreSize,
                           char* pbBuffer,
                           int pbSize,
                           int lines,
                           const char* shardHash,
                           int shardHashSize);

typedef int (*PluginCtlCmdFun)(
    const char* configName, int configNameSize, int optId, const char* params, int paramsLen);

typedef void (*RegisterLogtailCallBack)(IsValidToSendFun checkFun, SendPbFun sendFun, PluginCtlCmdFun cmdFun);
typedef void (*RegisterLogtailCallBackV2)(IsValidToSendFun checkFun,
                                          SendPbFun sendFun,
                                          SendPbV2Fun sendV2Fun,
                                          PluginCtlCmdFun cmdFun);

typedef int (*PluginAdapterVersion)();
}

// Create by david zhang. 2017/09/02 22:22:12
class LogtailPlugin {
public:
    LogtailPlugin();
    ~LogtailPlugin();

    enum PluginCmdType {
        PLUGIN_CMD_MIN = 0,
        PLUGIN_DOCKER_UPDATE_FILE = 1,
        PLUGIN_DOCKER_REMOVE_FILE = 2,
        PLUGIN_DOCKER_UPDATE_FILE_ALL = 3,
        PLUGIN_CMD_MAX = 4
    };

    static LogtailPlugin* GetInstance() {
        if (s_instance == NULL) {
            s_instance = new LogtailPlugin;
        }
        return s_instance;
    }

    static void FinalizeInstance() {
        if (s_instance != NULL) {
            delete s_instance;
            s_instance = NULL;
        }
    }

    bool LoadPluginBase();
    void LoadConfig();
    void HoldOn(bool exitFlag);
    void Resume();

    bool IsPluginOpened() { return mPluginValid; }

    void ProcessRawLog(const std::string& configName,
                       char* rawLog,
                       int32_t rawLogSize,
                       const std::string& packId,
                       const std::string& topic);

    void ProcessRawLogV2(const std::string& configName,
                         char* rawLog,
                         int32_t rawLogSize,
                         const std::string& packId,
                         const std::string& topic,
                         const std::string& tags);

    static int IsValidToSend(long long logstoreKey);

    static int SendPb(const char* configName,
                      int32_t configNameSize,
                      const char* logstore,
                      int logstoreSize,
                      char* pbBuffer,
                      int32_t pbSize,
                      int32_t lines);

    static int SendPbV2(const char* configName,
                        int32_t configNameSize,
                        const char* logstore,
                        int logstoreSize,
                        char* pbBuffer,
                        int32_t pbSize,
                        int32_t lines,
                        const char* shardHash,
                        int shardHashSize);

    static int ExecPluginCmd(const char* configName, int configNameSize, int cmdId, const char* params, int paramsLen);

private:
    void* mPluginBasePtr;
    void* mPluginAdapterPtr;

    LoadGlobalConfigFun mLoadGlobalConfigFun;
    LoadConfigFun mLoadConfigFun;
    UnloadConfigFun mUnloadConfigFun;
    HoldOnFun mHoldOnFun;
    ResumeFun mResumeFun;
    ProcessRawLogFun mProcessRawLogFun;
    ProcessRawLogV2Fun mProcessRawLogV2Fun;
    volatile bool mPluginValid;
    logtail::Config mPluginAlarmConfig;
    logtail::Config mPluginProfileConfig;

    // Configuration for plugin system in JSON format.
    Json::Value mPluginCfg;

private:
    static LogtailPlugin* s_instance;
};
