// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: agent.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_agent_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_agent_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3021000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3021005 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/map.h>  // IWYU pragma: export
#include <google/protobuf/map_entry.h>
#include <google/protobuf/map_field_inl.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_agent_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_agent_2eproto {
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_agent_2eproto;
namespace configserver {
namespace proto {
class AgentGetConfigListRequest;
struct AgentGetConfigListRequestDefaultTypeInternal;
extern AgentGetConfigListRequestDefaultTypeInternal _AgentGetConfigListRequest_default_instance_;
class AgentGetConfigListRequest_ConfigVersionsEntry_DoNotUse;
struct AgentGetConfigListRequest_ConfigVersionsEntry_DoNotUseDefaultTypeInternal;
extern AgentGetConfigListRequest_ConfigVersionsEntry_DoNotUseDefaultTypeInternal _AgentGetConfigListRequest_ConfigVersionsEntry_DoNotUse_default_instance_;
class AgentGetConfigListRequest_TagsEntry_DoNotUse;
struct AgentGetConfigListRequest_TagsEntry_DoNotUseDefaultTypeInternal;
extern AgentGetConfigListRequest_TagsEntry_DoNotUseDefaultTypeInternal _AgentGetConfigListRequest_TagsEntry_DoNotUse_default_instance_;
class AgentGetConfigListResponse;
struct AgentGetConfigListResponseDefaultTypeInternal;
extern AgentGetConfigListResponseDefaultTypeInternal _AgentGetConfigListResponse_default_instance_;
class AlarmRequest;
struct AlarmRequestDefaultTypeInternal;
extern AlarmRequestDefaultTypeInternal _AlarmRequest_default_instance_;
class AlarmResponse;
struct AlarmResponseDefaultTypeInternal;
extern AlarmResponseDefaultTypeInternal _AlarmResponse_default_instance_;
class ConfigUpdateInfo;
struct ConfigUpdateInfoDefaultTypeInternal;
extern ConfigUpdateInfoDefaultTypeInternal _ConfigUpdateInfo_default_instance_;
class HeartBeatRequest;
struct HeartBeatRequestDefaultTypeInternal;
extern HeartBeatRequestDefaultTypeInternal _HeartBeatRequest_default_instance_;
class HeartBeatRequest_TagsEntry_DoNotUse;
struct HeartBeatRequest_TagsEntry_DoNotUseDefaultTypeInternal;
extern HeartBeatRequest_TagsEntry_DoNotUseDefaultTypeInternal _HeartBeatRequest_TagsEntry_DoNotUse_default_instance_;
class HeartBeatResponse;
struct HeartBeatResponseDefaultTypeInternal;
extern HeartBeatResponseDefaultTypeInternal _HeartBeatResponse_default_instance_;
class RunningStatistics;
struct RunningStatisticsDefaultTypeInternal;
extern RunningStatisticsDefaultTypeInternal _RunningStatistics_default_instance_;
class RunningStatisticsRequest;
struct RunningStatisticsRequestDefaultTypeInternal;
extern RunningStatisticsRequestDefaultTypeInternal _RunningStatisticsRequest_default_instance_;
class RunningStatisticsResponse;
struct RunningStatisticsResponseDefaultTypeInternal;
extern RunningStatisticsResponseDefaultTypeInternal _RunningStatisticsResponse_default_instance_;
class RunningStatistics_ExtrasEntry_DoNotUse;
struct RunningStatistics_ExtrasEntry_DoNotUseDefaultTypeInternal;
extern RunningStatistics_ExtrasEntry_DoNotUseDefaultTypeInternal _RunningStatistics_ExtrasEntry_DoNotUse_default_instance_;
}  // namespace proto
}  // namespace configserver
PROTOBUF_NAMESPACE_OPEN
template<> ::configserver::proto::AgentGetConfigListRequest* Arena::CreateMaybeMessage<::configserver::proto::AgentGetConfigListRequest>(Arena*);
template<> ::configserver::proto::AgentGetConfigListRequest_ConfigVersionsEntry_DoNotUse* Arena::CreateMaybeMessage<::configserver::proto::AgentGetConfigListRequest_ConfigVersionsEntry_DoNotUse>(Arena*);
template<> ::configserver::proto::AgentGetConfigListRequest_TagsEntry_DoNotUse* Arena::CreateMaybeMessage<::configserver::proto::AgentGetConfigListRequest_TagsEntry_DoNotUse>(Arena*);
template<> ::configserver::proto::AgentGetConfigListResponse* Arena::CreateMaybeMessage<::configserver::proto::AgentGetConfigListResponse>(Arena*);
template<> ::configserver::proto::AlarmRequest* Arena::CreateMaybeMessage<::configserver::proto::AlarmRequest>(Arena*);
template<> ::configserver::proto::AlarmResponse* Arena::CreateMaybeMessage<::configserver::proto::AlarmResponse>(Arena*);
template<> ::configserver::proto::ConfigUpdateInfo* Arena::CreateMaybeMessage<::configserver::proto::ConfigUpdateInfo>(Arena*);
template<> ::configserver::proto::HeartBeatRequest* Arena::CreateMaybeMessage<::configserver::proto::HeartBeatRequest>(Arena*);
template<> ::configserver::proto::HeartBeatRequest_TagsEntry_DoNotUse* Arena::CreateMaybeMessage<::configserver::proto::HeartBeatRequest_TagsEntry_DoNotUse>(Arena*);
template<> ::configserver::proto::HeartBeatResponse* Arena::CreateMaybeMessage<::configserver::proto::HeartBeatResponse>(Arena*);
template<> ::configserver::proto::RunningStatistics* Arena::CreateMaybeMessage<::configserver::proto::RunningStatistics>(Arena*);
template<> ::configserver::proto::RunningStatisticsRequest* Arena::CreateMaybeMessage<::configserver::proto::RunningStatisticsRequest>(Arena*);
template<> ::configserver::proto::RunningStatisticsResponse* Arena::CreateMaybeMessage<::configserver::proto::RunningStatisticsResponse>(Arena*);
template<> ::configserver::proto::RunningStatistics_ExtrasEntry_DoNotUse* Arena::CreateMaybeMessage<::configserver::proto::RunningStatistics_ExtrasEntry_DoNotUse>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace configserver {
namespace proto {

enum ConfigUpdateInfo_UpdateStatus : int {
  ConfigUpdateInfo_UpdateStatus_SAME = 0,
  ConfigUpdateInfo_UpdateStatus_NEW = 1,
  ConfigUpdateInfo_UpdateStatus_DELETED = 2,
  ConfigUpdateInfo_UpdateStatus_MODIFIED = 3,
  ConfigUpdateInfo_UpdateStatus_ConfigUpdateInfo_UpdateStatus_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  ConfigUpdateInfo_UpdateStatus_ConfigUpdateInfo_UpdateStatus_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool ConfigUpdateInfo_UpdateStatus_IsValid(int value);
constexpr ConfigUpdateInfo_UpdateStatus ConfigUpdateInfo_UpdateStatus_UpdateStatus_MIN = ConfigUpdateInfo_UpdateStatus_SAME;
constexpr ConfigUpdateInfo_UpdateStatus ConfigUpdateInfo_UpdateStatus_UpdateStatus_MAX = ConfigUpdateInfo_UpdateStatus_MODIFIED;
constexpr int ConfigUpdateInfo_UpdateStatus_UpdateStatus_ARRAYSIZE = ConfigUpdateInfo_UpdateStatus_UpdateStatus_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ConfigUpdateInfo_UpdateStatus_descriptor();
template<typename T>
inline const std::string& ConfigUpdateInfo_UpdateStatus_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ConfigUpdateInfo_UpdateStatus>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ConfigUpdateInfo_UpdateStatus_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    ConfigUpdateInfo_UpdateStatus_descriptor(), enum_t_value);
}
inline bool ConfigUpdateInfo_UpdateStatus_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ConfigUpdateInfo_UpdateStatus* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<ConfigUpdateInfo_UpdateStatus>(
    ConfigUpdateInfo_UpdateStatus_descriptor(), name, value);
}
// ===================================================================

class HeartBeatRequest_TagsEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<HeartBeatRequest_TagsEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<HeartBeatRequest_TagsEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> SuperType;
  HeartBeatRequest_TagsEntry_DoNotUse();
  explicit PROTOBUF_CONSTEXPR HeartBeatRequest_TagsEntry_DoNotUse(
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
  explicit HeartBeatRequest_TagsEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const HeartBeatRequest_TagsEntry_DoNotUse& other);
  static const HeartBeatRequest_TagsEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const HeartBeatRequest_TagsEntry_DoNotUse*>(&_HeartBeatRequest_TagsEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "configserver.proto.HeartBeatRequest.TagsEntry.key");
 }
  static bool ValidateValue(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "configserver.proto.HeartBeatRequest.TagsEntry.value");
 }
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  friend struct ::TableStruct_agent_2eproto;
};

// -------------------------------------------------------------------

class HeartBeatRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:configserver.proto.HeartBeatRequest) */ {
 public:
  inline HeartBeatRequest() : HeartBeatRequest(nullptr) {}
  ~HeartBeatRequest() override;
  explicit PROTOBUF_CONSTEXPR HeartBeatRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  HeartBeatRequest(const HeartBeatRequest& from);
  HeartBeatRequest(HeartBeatRequest&& from) noexcept
    : HeartBeatRequest() {
    *this = ::std::move(from);
  }

  inline HeartBeatRequest& operator=(const HeartBeatRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline HeartBeatRequest& operator=(HeartBeatRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const HeartBeatRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const HeartBeatRequest* internal_default_instance() {
    return reinterpret_cast<const HeartBeatRequest*>(
               &_HeartBeatRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(HeartBeatRequest& a, HeartBeatRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(HeartBeatRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(HeartBeatRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  HeartBeatRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<HeartBeatRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const HeartBeatRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const HeartBeatRequest& from) {
    HeartBeatRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(HeartBeatRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "configserver.proto.HeartBeatRequest";
  }
  protected:
  explicit HeartBeatRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  enum : int {
    kTagsFieldNumber = 6,
    kRequestIdFieldNumber = 1,
    kAgentIdFieldNumber = 2,
    kAgentTypeFieldNumber = 3,
    kAgentVersionFieldNumber = 4,
    kIpFieldNumber = 5,
    kRunningStatusFieldNumber = 7,
    kStartupTimeFieldNumber = 8,
  };
  // map<string, string> tags = 6;
  int tags_size() const;
  private:
  int _internal_tags_size() const;
  public:
  void clear_tags();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      _internal_tags() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      _internal_mutable_tags();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      tags() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      mutable_tags();

  // string request_id = 1;
  void clear_request_id();
  const std::string& request_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_request_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_request_id();
  PROTOBUF_NODISCARD std::string* release_request_id();
  void set_allocated_request_id(std::string* request_id);
  private:
  const std::string& _internal_request_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_request_id(const std::string& value);
  std::string* _internal_mutable_request_id();
  public:

  // string agent_id = 2;
  void clear_agent_id();
  const std::string& agent_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_agent_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_agent_id();
  PROTOBUF_NODISCARD std::string* release_agent_id();
  void set_allocated_agent_id(std::string* agent_id);
  private:
  const std::string& _internal_agent_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_agent_id(const std::string& value);
  std::string* _internal_mutable_agent_id();
  public:

  // string agent_type = 3;
  void clear_agent_type();
  const std::string& agent_type() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_agent_type(ArgT0&& arg0, ArgT... args);
  std::string* mutable_agent_type();
  PROTOBUF_NODISCARD std::string* release_agent_type();
  void set_allocated_agent_type(std::string* agent_type);
  private:
  const std::string& _internal_agent_type() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_agent_type(const std::string& value);
  std::string* _internal_mutable_agent_type();
  public:

  // string agent_version = 4;
  void clear_agent_version();
  const std::string& agent_version() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_agent_version(ArgT0&& arg0, ArgT... args);
  std::string* mutable_agent_version();
  PROTOBUF_NODISCARD std::string* release_agent_version();
  void set_allocated_agent_version(std::string* agent_version);
  private:
  const std::string& _internal_agent_version() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_agent_version(const std::string& value);
  std::string* _internal_mutable_agent_version();
  public:

  // string ip = 5;
  void clear_ip();
  const std::string& ip() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_ip(ArgT0&& arg0, ArgT... args);
  std::string* mutable_ip();
  PROTOBUF_NODISCARD std::string* release_ip();
  void set_allocated_ip(std::string* ip);
  private:
  const std::string& _internal_ip() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_ip(const std::string& value);
  std::string* _internal_mutable_ip();
  public:

  // string running_status = 7;
  void clear_running_status();
  const std::string& running_status() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_running_status(ArgT0&& arg0, ArgT... args);
  std::string* mutable_running_status();
  PROTOBUF_NODISCARD std::string* release_running_status();
  void set_allocated_running_status(std::string* running_status);
  private:
  const std::string& _internal_running_status() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_running_status(const std::string& value);
  std::string* _internal_mutable_running_status();
  public:

  // int64 startup_time = 8;
  void clear_startup_time();
  int64_t startup_time() const;
  void set_startup_time(int64_t value);
  private:
  int64_t _internal_startup_time() const;
  void _internal_set_startup_time(int64_t value);
  public:

  // @@protoc_insertion_point(class_scope:configserver.proto.HeartBeatRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::MapField<
        HeartBeatRequest_TagsEntry_DoNotUse,
        std::string, std::string,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> tags_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr request_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr agent_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr agent_type_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr agent_version_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr ip_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr running_status_;
    int64_t startup_time_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_agent_2eproto;
};
// -------------------------------------------------------------------

class HeartBeatResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:configserver.proto.HeartBeatResponse) */ {
 public:
  inline HeartBeatResponse() : HeartBeatResponse(nullptr) {}
  ~HeartBeatResponse() override;
  explicit PROTOBUF_CONSTEXPR HeartBeatResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  HeartBeatResponse(const HeartBeatResponse& from);
  HeartBeatResponse(HeartBeatResponse&& from) noexcept
    : HeartBeatResponse() {
    *this = ::std::move(from);
  }

  inline HeartBeatResponse& operator=(const HeartBeatResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline HeartBeatResponse& operator=(HeartBeatResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const HeartBeatResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const HeartBeatResponse* internal_default_instance() {
    return reinterpret_cast<const HeartBeatResponse*>(
               &_HeartBeatResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(HeartBeatResponse& a, HeartBeatResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(HeartBeatResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(HeartBeatResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  HeartBeatResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<HeartBeatResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const HeartBeatResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const HeartBeatResponse& from) {
    HeartBeatResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(HeartBeatResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "configserver.proto.HeartBeatResponse";
  }
  protected:
  explicit HeartBeatResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kResponseIdFieldNumber = 1,
    kCodeFieldNumber = 2,
    kMessageFieldNumber = 3,
  };
  // string response_id = 1;
  void clear_response_id();
  const std::string& response_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_response_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_response_id();
  PROTOBUF_NODISCARD std::string* release_response_id();
  void set_allocated_response_id(std::string* response_id);
  private:
  const std::string& _internal_response_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_response_id(const std::string& value);
  std::string* _internal_mutable_response_id();
  public:

  // string code = 2;
  void clear_code();
  const std::string& code() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_code(ArgT0&& arg0, ArgT... args);
  std::string* mutable_code();
  PROTOBUF_NODISCARD std::string* release_code();
  void set_allocated_code(std::string* code);
  private:
  const std::string& _internal_code() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_code(const std::string& value);
  std::string* _internal_mutable_code();
  public:

  // string message = 3;
  void clear_message();
  const std::string& message() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_message(ArgT0&& arg0, ArgT... args);
  std::string* mutable_message();
  PROTOBUF_NODISCARD std::string* release_message();
  void set_allocated_message(std::string* message);
  private:
  const std::string& _internal_message() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_message(const std::string& value);
  std::string* _internal_mutable_message();
  public:

  // @@protoc_insertion_point(class_scope:configserver.proto.HeartBeatResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr response_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr code_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr message_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_agent_2eproto;
};
// -------------------------------------------------------------------

class RunningStatistics_ExtrasEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<RunningStatistics_ExtrasEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<RunningStatistics_ExtrasEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> SuperType;
  RunningStatistics_ExtrasEntry_DoNotUse();
  explicit PROTOBUF_CONSTEXPR RunningStatistics_ExtrasEntry_DoNotUse(
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
  explicit RunningStatistics_ExtrasEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const RunningStatistics_ExtrasEntry_DoNotUse& other);
  static const RunningStatistics_ExtrasEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const RunningStatistics_ExtrasEntry_DoNotUse*>(&_RunningStatistics_ExtrasEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "configserver.proto.RunningStatistics.ExtrasEntry.key");
 }
  static bool ValidateValue(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "configserver.proto.RunningStatistics.ExtrasEntry.value");
 }
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  friend struct ::TableStruct_agent_2eproto;
};

// -------------------------------------------------------------------

class RunningStatistics final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:configserver.proto.RunningStatistics) */ {
 public:
  inline RunningStatistics() : RunningStatistics(nullptr) {}
  ~RunningStatistics() override;
  explicit PROTOBUF_CONSTEXPR RunningStatistics(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RunningStatistics(const RunningStatistics& from);
  RunningStatistics(RunningStatistics&& from) noexcept
    : RunningStatistics() {
    *this = ::std::move(from);
  }

  inline RunningStatistics& operator=(const RunningStatistics& from) {
    CopyFrom(from);
    return *this;
  }
  inline RunningStatistics& operator=(RunningStatistics&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RunningStatistics& default_instance() {
    return *internal_default_instance();
  }
  static inline const RunningStatistics* internal_default_instance() {
    return reinterpret_cast<const RunningStatistics*>(
               &_RunningStatistics_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(RunningStatistics& a, RunningStatistics& b) {
    a.Swap(&b);
  }
  inline void Swap(RunningStatistics* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RunningStatistics* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RunningStatistics* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RunningStatistics>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RunningStatistics& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const RunningStatistics& from) {
    RunningStatistics::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RunningStatistics* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "configserver.proto.RunningStatistics";
  }
  protected:
  explicit RunningStatistics(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  enum : int {
    kExtrasFieldNumber = 100,
    kMemoryFieldNumber = 2,
    kCpuFieldNumber = 1,
  };
  // map<string, string> extras = 100;
  int extras_size() const;
  private:
  int _internal_extras_size() const;
  public:
  void clear_extras();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      _internal_extras() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      _internal_mutable_extras();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      extras() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      mutable_extras();

  // int64 memory = 2;
  void clear_memory();
  int64_t memory() const;
  void set_memory(int64_t value);
  private:
  int64_t _internal_memory() const;
  void _internal_set_memory(int64_t value);
  public:

  // float cpu = 1;
  void clear_cpu();
  float cpu() const;
  void set_cpu(float value);
  private:
  float _internal_cpu() const;
  void _internal_set_cpu(float value);
  public:

  // @@protoc_insertion_point(class_scope:configserver.proto.RunningStatistics)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::MapField<
        RunningStatistics_ExtrasEntry_DoNotUse,
        std::string, std::string,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> extras_;
    int64_t memory_;
    float cpu_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_agent_2eproto;
};
// -------------------------------------------------------------------

class RunningStatisticsRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:configserver.proto.RunningStatisticsRequest) */ {
 public:
  inline RunningStatisticsRequest() : RunningStatisticsRequest(nullptr) {}
  ~RunningStatisticsRequest() override;
  explicit PROTOBUF_CONSTEXPR RunningStatisticsRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RunningStatisticsRequest(const RunningStatisticsRequest& from);
  RunningStatisticsRequest(RunningStatisticsRequest&& from) noexcept
    : RunningStatisticsRequest() {
    *this = ::std::move(from);
  }

  inline RunningStatisticsRequest& operator=(const RunningStatisticsRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline RunningStatisticsRequest& operator=(RunningStatisticsRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RunningStatisticsRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const RunningStatisticsRequest* internal_default_instance() {
    return reinterpret_cast<const RunningStatisticsRequest*>(
               &_RunningStatisticsRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(RunningStatisticsRequest& a, RunningStatisticsRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(RunningStatisticsRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RunningStatisticsRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RunningStatisticsRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RunningStatisticsRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RunningStatisticsRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const RunningStatisticsRequest& from) {
    RunningStatisticsRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RunningStatisticsRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "configserver.proto.RunningStatisticsRequest";
  }
  protected:
  explicit RunningStatisticsRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRequestIdFieldNumber = 1,
    kAgentIdFieldNumber = 2,
    kRunningDetailsFieldNumber = 3,
  };
  // string request_id = 1;
  void clear_request_id();
  const std::string& request_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_request_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_request_id();
  PROTOBUF_NODISCARD std::string* release_request_id();
  void set_allocated_request_id(std::string* request_id);
  private:
  const std::string& _internal_request_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_request_id(const std::string& value);
  std::string* _internal_mutable_request_id();
  public:

  // string agent_id = 2;
  void clear_agent_id();
  const std::string& agent_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_agent_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_agent_id();
  PROTOBUF_NODISCARD std::string* release_agent_id();
  void set_allocated_agent_id(std::string* agent_id);
  private:
  const std::string& _internal_agent_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_agent_id(const std::string& value);
  std::string* _internal_mutable_agent_id();
  public:

  // .configserver.proto.RunningStatistics running_details = 3;
  bool has_running_details() const;
  private:
  bool _internal_has_running_details() const;
  public:
  void clear_running_details();
  const ::configserver::proto::RunningStatistics& running_details() const;
  PROTOBUF_NODISCARD ::configserver::proto::RunningStatistics* release_running_details();
  ::configserver::proto::RunningStatistics* mutable_running_details();
  void set_allocated_running_details(::configserver::proto::RunningStatistics* running_details);
  private:
  const ::configserver::proto::RunningStatistics& _internal_running_details() const;
  ::configserver::proto::RunningStatistics* _internal_mutable_running_details();
  public:
  void unsafe_arena_set_allocated_running_details(
      ::configserver::proto::RunningStatistics* running_details);
  ::configserver::proto::RunningStatistics* unsafe_arena_release_running_details();

  // @@protoc_insertion_point(class_scope:configserver.proto.RunningStatisticsRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr request_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr agent_id_;
    ::configserver::proto::RunningStatistics* running_details_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_agent_2eproto;
};
// -------------------------------------------------------------------

class RunningStatisticsResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:configserver.proto.RunningStatisticsResponse) */ {
 public:
  inline RunningStatisticsResponse() : RunningStatisticsResponse(nullptr) {}
  ~RunningStatisticsResponse() override;
  explicit PROTOBUF_CONSTEXPR RunningStatisticsResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RunningStatisticsResponse(const RunningStatisticsResponse& from);
  RunningStatisticsResponse(RunningStatisticsResponse&& from) noexcept
    : RunningStatisticsResponse() {
    *this = ::std::move(from);
  }

  inline RunningStatisticsResponse& operator=(const RunningStatisticsResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline RunningStatisticsResponse& operator=(RunningStatisticsResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RunningStatisticsResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const RunningStatisticsResponse* internal_default_instance() {
    return reinterpret_cast<const RunningStatisticsResponse*>(
               &_RunningStatisticsResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(RunningStatisticsResponse& a, RunningStatisticsResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(RunningStatisticsResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RunningStatisticsResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RunningStatisticsResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RunningStatisticsResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RunningStatisticsResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const RunningStatisticsResponse& from) {
    RunningStatisticsResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RunningStatisticsResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "configserver.proto.RunningStatisticsResponse";
  }
  protected:
  explicit RunningStatisticsResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kResponseIdFieldNumber = 1,
    kCodeFieldNumber = 2,
    kMessageFieldNumber = 3,
  };
  // string response_id = 1;
  void clear_response_id();
  const std::string& response_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_response_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_response_id();
  PROTOBUF_NODISCARD std::string* release_response_id();
  void set_allocated_response_id(std::string* response_id);
  private:
  const std::string& _internal_response_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_response_id(const std::string& value);
  std::string* _internal_mutable_response_id();
  public:

  // string code = 2;
  void clear_code();
  const std::string& code() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_code(ArgT0&& arg0, ArgT... args);
  std::string* mutable_code();
  PROTOBUF_NODISCARD std::string* release_code();
  void set_allocated_code(std::string* code);
  private:
  const std::string& _internal_code() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_code(const std::string& value);
  std::string* _internal_mutable_code();
  public:

  // string message = 3;
  void clear_message();
  const std::string& message() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_message(ArgT0&& arg0, ArgT... args);
  std::string* mutable_message();
  PROTOBUF_NODISCARD std::string* release_message();
  void set_allocated_message(std::string* message);
  private:
  const std::string& _internal_message() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_message(const std::string& value);
  std::string* _internal_mutable_message();
  public:

  // @@protoc_insertion_point(class_scope:configserver.proto.RunningStatisticsResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr response_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr code_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr message_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_agent_2eproto;
};
// -------------------------------------------------------------------

class AlarmRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:configserver.proto.AlarmRequest) */ {
 public:
  inline AlarmRequest() : AlarmRequest(nullptr) {}
  ~AlarmRequest() override;
  explicit PROTOBUF_CONSTEXPR AlarmRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AlarmRequest(const AlarmRequest& from);
  AlarmRequest(AlarmRequest&& from) noexcept
    : AlarmRequest() {
    *this = ::std::move(from);
  }

  inline AlarmRequest& operator=(const AlarmRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline AlarmRequest& operator=(AlarmRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AlarmRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const AlarmRequest* internal_default_instance() {
    return reinterpret_cast<const AlarmRequest*>(
               &_AlarmRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(AlarmRequest& a, AlarmRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(AlarmRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AlarmRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AlarmRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AlarmRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const AlarmRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const AlarmRequest& from) {
    AlarmRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AlarmRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "configserver.proto.AlarmRequest";
  }
  protected:
  explicit AlarmRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRequestIdFieldNumber = 1,
    kAgentIdFieldNumber = 2,
    kTypeFieldNumber = 3,
    kDetailFieldNumber = 4,
  };
  // string request_id = 1;
  void clear_request_id();
  const std::string& request_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_request_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_request_id();
  PROTOBUF_NODISCARD std::string* release_request_id();
  void set_allocated_request_id(std::string* request_id);
  private:
  const std::string& _internal_request_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_request_id(const std::string& value);
  std::string* _internal_mutable_request_id();
  public:

  // string agent_id = 2;
  void clear_agent_id();
  const std::string& agent_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_agent_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_agent_id();
  PROTOBUF_NODISCARD std::string* release_agent_id();
  void set_allocated_agent_id(std::string* agent_id);
  private:
  const std::string& _internal_agent_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_agent_id(const std::string& value);
  std::string* _internal_mutable_agent_id();
  public:

  // string type = 3;
  void clear_type();
  const std::string& type() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_type(ArgT0&& arg0, ArgT... args);
  std::string* mutable_type();
  PROTOBUF_NODISCARD std::string* release_type();
  void set_allocated_type(std::string* type);
  private:
  const std::string& _internal_type() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_type(const std::string& value);
  std::string* _internal_mutable_type();
  public:

  // string detail = 4;
  void clear_detail();
  const std::string& detail() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_detail(ArgT0&& arg0, ArgT... args);
  std::string* mutable_detail();
  PROTOBUF_NODISCARD std::string* release_detail();
  void set_allocated_detail(std::string* detail);
  private:
  const std::string& _internal_detail() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_detail(const std::string& value);
  std::string* _internal_mutable_detail();
  public:

  // @@protoc_insertion_point(class_scope:configserver.proto.AlarmRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr request_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr agent_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr type_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr detail_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_agent_2eproto;
};
// -------------------------------------------------------------------

class AlarmResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:configserver.proto.AlarmResponse) */ {
 public:
  inline AlarmResponse() : AlarmResponse(nullptr) {}
  ~AlarmResponse() override;
  explicit PROTOBUF_CONSTEXPR AlarmResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AlarmResponse(const AlarmResponse& from);
  AlarmResponse(AlarmResponse&& from) noexcept
    : AlarmResponse() {
    *this = ::std::move(from);
  }

  inline AlarmResponse& operator=(const AlarmResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline AlarmResponse& operator=(AlarmResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AlarmResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const AlarmResponse* internal_default_instance() {
    return reinterpret_cast<const AlarmResponse*>(
               &_AlarmResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(AlarmResponse& a, AlarmResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(AlarmResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AlarmResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AlarmResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AlarmResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const AlarmResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const AlarmResponse& from) {
    AlarmResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AlarmResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "configserver.proto.AlarmResponse";
  }
  protected:
  explicit AlarmResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kResponseIdFieldNumber = 1,
    kCodeFieldNumber = 2,
    kMessageFieldNumber = 3,
  };
  // string response_id = 1;
  void clear_response_id();
  const std::string& response_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_response_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_response_id();
  PROTOBUF_NODISCARD std::string* release_response_id();
  void set_allocated_response_id(std::string* response_id);
  private:
  const std::string& _internal_response_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_response_id(const std::string& value);
  std::string* _internal_mutable_response_id();
  public:

  // string code = 2;
  void clear_code();
  const std::string& code() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_code(ArgT0&& arg0, ArgT... args);
  std::string* mutable_code();
  PROTOBUF_NODISCARD std::string* release_code();
  void set_allocated_code(std::string* code);
  private:
  const std::string& _internal_code() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_code(const std::string& value);
  std::string* _internal_mutable_code();
  public:

  // string message = 3;
  void clear_message();
  const std::string& message() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_message(ArgT0&& arg0, ArgT... args);
  std::string* mutable_message();
  PROTOBUF_NODISCARD std::string* release_message();
  void set_allocated_message(std::string* message);
  private:
  const std::string& _internal_message() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_message(const std::string& value);
  std::string* _internal_mutable_message();
  public:

  // @@protoc_insertion_point(class_scope:configserver.proto.AlarmResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr response_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr code_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr message_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_agent_2eproto;
};
// -------------------------------------------------------------------

class AgentGetConfigListRequest_ConfigVersionsEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<AgentGetConfigListRequest_ConfigVersionsEntry_DoNotUse, 
    std::string, int64_t,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT64> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<AgentGetConfigListRequest_ConfigVersionsEntry_DoNotUse, 
    std::string, int64_t,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT64> SuperType;
  AgentGetConfigListRequest_ConfigVersionsEntry_DoNotUse();
  explicit PROTOBUF_CONSTEXPR AgentGetConfigListRequest_ConfigVersionsEntry_DoNotUse(
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
  explicit AgentGetConfigListRequest_ConfigVersionsEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const AgentGetConfigListRequest_ConfigVersionsEntry_DoNotUse& other);
  static const AgentGetConfigListRequest_ConfigVersionsEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const AgentGetConfigListRequest_ConfigVersionsEntry_DoNotUse*>(&_AgentGetConfigListRequest_ConfigVersionsEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "configserver.proto.AgentGetConfigListRequest.ConfigVersionsEntry.key");
 }
  static bool ValidateValue(void*) { return true; }
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  friend struct ::TableStruct_agent_2eproto;
};

// -------------------------------------------------------------------

class AgentGetConfigListRequest_TagsEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<AgentGetConfigListRequest_TagsEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<AgentGetConfigListRequest_TagsEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> SuperType;
  AgentGetConfigListRequest_TagsEntry_DoNotUse();
  explicit PROTOBUF_CONSTEXPR AgentGetConfigListRequest_TagsEntry_DoNotUse(
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
  explicit AgentGetConfigListRequest_TagsEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const AgentGetConfigListRequest_TagsEntry_DoNotUse& other);
  static const AgentGetConfigListRequest_TagsEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const AgentGetConfigListRequest_TagsEntry_DoNotUse*>(&_AgentGetConfigListRequest_TagsEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "configserver.proto.AgentGetConfigListRequest.TagsEntry.key");
 }
  static bool ValidateValue(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "configserver.proto.AgentGetConfigListRequest.TagsEntry.value");
 }
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  friend struct ::TableStruct_agent_2eproto;
};

// -------------------------------------------------------------------

class AgentGetConfigListRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:configserver.proto.AgentGetConfigListRequest) */ {
 public:
  inline AgentGetConfigListRequest() : AgentGetConfigListRequest(nullptr) {}
  ~AgentGetConfigListRequest() override;
  explicit PROTOBUF_CONSTEXPR AgentGetConfigListRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AgentGetConfigListRequest(const AgentGetConfigListRequest& from);
  AgentGetConfigListRequest(AgentGetConfigListRequest&& from) noexcept
    : AgentGetConfigListRequest() {
    *this = ::std::move(from);
  }

  inline AgentGetConfigListRequest& operator=(const AgentGetConfigListRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline AgentGetConfigListRequest& operator=(AgentGetConfigListRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AgentGetConfigListRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const AgentGetConfigListRequest* internal_default_instance() {
    return reinterpret_cast<const AgentGetConfigListRequest*>(
               &_AgentGetConfigListRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(AgentGetConfigListRequest& a, AgentGetConfigListRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(AgentGetConfigListRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AgentGetConfigListRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AgentGetConfigListRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AgentGetConfigListRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const AgentGetConfigListRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const AgentGetConfigListRequest& from) {
    AgentGetConfigListRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AgentGetConfigListRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "configserver.proto.AgentGetConfigListRequest";
  }
  protected:
  explicit AgentGetConfigListRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  enum : int {
    kConfigVersionsFieldNumber = 3,
    kTagsFieldNumber = 4,
    kRequestIdFieldNumber = 1,
    kAgentIdFieldNumber = 2,
  };
  // map<string, int64> config_versions = 3;
  int config_versions_size() const;
  private:
  int _internal_config_versions_size() const;
  public:
  void clear_config_versions();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, int64_t >&
      _internal_config_versions() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, int64_t >*
      _internal_mutable_config_versions();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, int64_t >&
      config_versions() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, int64_t >*
      mutable_config_versions();

  // map<string, string> tags = 4;
  int tags_size() const;
  private:
  int _internal_tags_size() const;
  public:
  void clear_tags();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      _internal_tags() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      _internal_mutable_tags();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      tags() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      mutable_tags();

  // string request_id = 1;
  void clear_request_id();
  const std::string& request_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_request_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_request_id();
  PROTOBUF_NODISCARD std::string* release_request_id();
  void set_allocated_request_id(std::string* request_id);
  private:
  const std::string& _internal_request_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_request_id(const std::string& value);
  std::string* _internal_mutable_request_id();
  public:

  // string agent_id = 2;
  void clear_agent_id();
  const std::string& agent_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_agent_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_agent_id();
  PROTOBUF_NODISCARD std::string* release_agent_id();
  void set_allocated_agent_id(std::string* agent_id);
  private:
  const std::string& _internal_agent_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_agent_id(const std::string& value);
  std::string* _internal_mutable_agent_id();
  public:

  // @@protoc_insertion_point(class_scope:configserver.proto.AgentGetConfigListRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::MapField<
        AgentGetConfigListRequest_ConfigVersionsEntry_DoNotUse,
        std::string, int64_t,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT64> config_versions_;
    ::PROTOBUF_NAMESPACE_ID::internal::MapField<
        AgentGetConfigListRequest_TagsEntry_DoNotUse,
        std::string, std::string,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> tags_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr request_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr agent_id_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_agent_2eproto;
};
// -------------------------------------------------------------------

class ConfigUpdateInfo final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:configserver.proto.ConfigUpdateInfo) */ {
 public:
  inline ConfigUpdateInfo() : ConfigUpdateInfo(nullptr) {}
  ~ConfigUpdateInfo() override;
  explicit PROTOBUF_CONSTEXPR ConfigUpdateInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ConfigUpdateInfo(const ConfigUpdateInfo& from);
  ConfigUpdateInfo(ConfigUpdateInfo&& from) noexcept
    : ConfigUpdateInfo() {
    *this = ::std::move(from);
  }

  inline ConfigUpdateInfo& operator=(const ConfigUpdateInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline ConfigUpdateInfo& operator=(ConfigUpdateInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ConfigUpdateInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const ConfigUpdateInfo* internal_default_instance() {
    return reinterpret_cast<const ConfigUpdateInfo*>(
               &_ConfigUpdateInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(ConfigUpdateInfo& a, ConfigUpdateInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(ConfigUpdateInfo* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ConfigUpdateInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ConfigUpdateInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ConfigUpdateInfo>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ConfigUpdateInfo& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ConfigUpdateInfo& from) {
    ConfigUpdateInfo::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ConfigUpdateInfo* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "configserver.proto.ConfigUpdateInfo";
  }
  protected:
  explicit ConfigUpdateInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef ConfigUpdateInfo_UpdateStatus UpdateStatus;
  static constexpr UpdateStatus SAME =
    ConfigUpdateInfo_UpdateStatus_SAME;
  static constexpr UpdateStatus NEW =
    ConfigUpdateInfo_UpdateStatus_NEW;
  static constexpr UpdateStatus DELETED =
    ConfigUpdateInfo_UpdateStatus_DELETED;
  static constexpr UpdateStatus MODIFIED =
    ConfigUpdateInfo_UpdateStatus_MODIFIED;
  static inline bool UpdateStatus_IsValid(int value) {
    return ConfigUpdateInfo_UpdateStatus_IsValid(value);
  }
  static constexpr UpdateStatus UpdateStatus_MIN =
    ConfigUpdateInfo_UpdateStatus_UpdateStatus_MIN;
  static constexpr UpdateStatus UpdateStatus_MAX =
    ConfigUpdateInfo_UpdateStatus_UpdateStatus_MAX;
  static constexpr int UpdateStatus_ARRAYSIZE =
    ConfigUpdateInfo_UpdateStatus_UpdateStatus_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  UpdateStatus_descriptor() {
    return ConfigUpdateInfo_UpdateStatus_descriptor();
  }
  template<typename T>
  static inline const std::string& UpdateStatus_Name(T enum_t_value) {
    static_assert(::std::is_same<T, UpdateStatus>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function UpdateStatus_Name.");
    return ConfigUpdateInfo_UpdateStatus_Name(enum_t_value);
  }
  static inline bool UpdateStatus_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      UpdateStatus* value) {
    return ConfigUpdateInfo_UpdateStatus_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kConfigNameFieldNumber = 1,
    kContentFieldNumber = 4,
    kConfigVersionFieldNumber = 3,
    kUpdateStatusFieldNumber = 2,
  };
  // string config_name = 1;
  void clear_config_name();
  const std::string& config_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_config_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_config_name();
  PROTOBUF_NODISCARD std::string* release_config_name();
  void set_allocated_config_name(std::string* config_name);
  private:
  const std::string& _internal_config_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_config_name(const std::string& value);
  std::string* _internal_mutable_config_name();
  public:

  // string content = 4;
  void clear_content();
  const std::string& content() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_content(ArgT0&& arg0, ArgT... args);
  std::string* mutable_content();
  PROTOBUF_NODISCARD std::string* release_content();
  void set_allocated_content(std::string* content);
  private:
  const std::string& _internal_content() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_content(const std::string& value);
  std::string* _internal_mutable_content();
  public:

  // int64 config_version = 3;
  void clear_config_version();
  int64_t config_version() const;
  void set_config_version(int64_t value);
  private:
  int64_t _internal_config_version() const;
  void _internal_set_config_version(int64_t value);
  public:

  // .configserver.proto.ConfigUpdateInfo.UpdateStatus update_status = 2;
  void clear_update_status();
  ::configserver::proto::ConfigUpdateInfo_UpdateStatus update_status() const;
  void set_update_status(::configserver::proto::ConfigUpdateInfo_UpdateStatus value);
  private:
  ::configserver::proto::ConfigUpdateInfo_UpdateStatus _internal_update_status() const;
  void _internal_set_update_status(::configserver::proto::ConfigUpdateInfo_UpdateStatus value);
  public:

  // @@protoc_insertion_point(class_scope:configserver.proto.ConfigUpdateInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr config_name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr content_;
    int64_t config_version_;
    int update_status_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_agent_2eproto;
};
// -------------------------------------------------------------------

class AgentGetConfigListResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:configserver.proto.AgentGetConfigListResponse) */ {
 public:
  inline AgentGetConfigListResponse() : AgentGetConfigListResponse(nullptr) {}
  ~AgentGetConfigListResponse() override;
  explicit PROTOBUF_CONSTEXPR AgentGetConfigListResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AgentGetConfigListResponse(const AgentGetConfigListResponse& from);
  AgentGetConfigListResponse(AgentGetConfigListResponse&& from) noexcept
    : AgentGetConfigListResponse() {
    *this = ::std::move(from);
  }

  inline AgentGetConfigListResponse& operator=(const AgentGetConfigListResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline AgentGetConfigListResponse& operator=(AgentGetConfigListResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AgentGetConfigListResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const AgentGetConfigListResponse* internal_default_instance() {
    return reinterpret_cast<const AgentGetConfigListResponse*>(
               &_AgentGetConfigListResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(AgentGetConfigListResponse& a, AgentGetConfigListResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(AgentGetConfigListResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AgentGetConfigListResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AgentGetConfigListResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AgentGetConfigListResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const AgentGetConfigListResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const AgentGetConfigListResponse& from) {
    AgentGetConfigListResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AgentGetConfigListResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "configserver.proto.AgentGetConfigListResponse";
  }
  protected:
  explicit AgentGetConfigListResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kConfigUpdateInfosFieldNumber = 4,
    kResponseIdFieldNumber = 1,
    kCodeFieldNumber = 2,
    kMessageFieldNumber = 3,
  };
  // repeated .configserver.proto.ConfigUpdateInfo config_update_infos = 4;
  int config_update_infos_size() const;
  private:
  int _internal_config_update_infos_size() const;
  public:
  void clear_config_update_infos();
  ::configserver::proto::ConfigUpdateInfo* mutable_config_update_infos(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::configserver::proto::ConfigUpdateInfo >*
      mutable_config_update_infos();
  private:
  const ::configserver::proto::ConfigUpdateInfo& _internal_config_update_infos(int index) const;
  ::configserver::proto::ConfigUpdateInfo* _internal_add_config_update_infos();
  public:
  const ::configserver::proto::ConfigUpdateInfo& config_update_infos(int index) const;
  ::configserver::proto::ConfigUpdateInfo* add_config_update_infos();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::configserver::proto::ConfigUpdateInfo >&
      config_update_infos() const;

  // string response_id = 1;
  void clear_response_id();
  const std::string& response_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_response_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_response_id();
  PROTOBUF_NODISCARD std::string* release_response_id();
  void set_allocated_response_id(std::string* response_id);
  private:
  const std::string& _internal_response_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_response_id(const std::string& value);
  std::string* _internal_mutable_response_id();
  public:

  // string code = 2;
  void clear_code();
  const std::string& code() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_code(ArgT0&& arg0, ArgT... args);
  std::string* mutable_code();
  PROTOBUF_NODISCARD std::string* release_code();
  void set_allocated_code(std::string* code);
  private:
  const std::string& _internal_code() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_code(const std::string& value);
  std::string* _internal_mutable_code();
  public:

  // string message = 3;
  void clear_message();
  const std::string& message() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_message(ArgT0&& arg0, ArgT... args);
  std::string* mutable_message();
  PROTOBUF_NODISCARD std::string* release_message();
  void set_allocated_message(std::string* message);
  private:
  const std::string& _internal_message() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_message(const std::string& value);
  std::string* _internal_mutable_message();
  public:

  // @@protoc_insertion_point(class_scope:configserver.proto.AgentGetConfigListResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::configserver::proto::ConfigUpdateInfo > config_update_infos_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr response_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr code_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr message_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_agent_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// -------------------------------------------------------------------

// HeartBeatRequest

// string request_id = 1;
inline void HeartBeatRequest::clear_request_id() {
  _impl_.request_id_.ClearToEmpty();
}
inline const std::string& HeartBeatRequest::request_id() const {
  // @@protoc_insertion_point(field_get:configserver.proto.HeartBeatRequest.request_id)
  return _internal_request_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void HeartBeatRequest::set_request_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.request_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:configserver.proto.HeartBeatRequest.request_id)
}
inline std::string* HeartBeatRequest::mutable_request_id() {
  std::string* _s = _internal_mutable_request_id();
  // @@protoc_insertion_point(field_mutable:configserver.proto.HeartBeatRequest.request_id)
  return _s;
}
inline const std::string& HeartBeatRequest::_internal_request_id() const {
  return _impl_.request_id_.Get();
}
inline void HeartBeatRequest::_internal_set_request_id(const std::string& value) {
  
  _impl_.request_id_.Set(value, GetArenaForAllocation());
}
inline std::string* HeartBeatRequest::_internal_mutable_request_id() {
  
  return _impl_.request_id_.Mutable(GetArenaForAllocation());
}
inline std::string* HeartBeatRequest::release_request_id() {
  // @@protoc_insertion_point(field_release:configserver.proto.HeartBeatRequest.request_id)
  return _impl_.request_id_.Release();
}
inline void HeartBeatRequest::set_allocated_request_id(std::string* request_id) {
  if (request_id != nullptr) {
    
  } else {
    
  }
  _impl_.request_id_.SetAllocated(request_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.request_id_.IsDefault()) {
    _impl_.request_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:configserver.proto.HeartBeatRequest.request_id)
}

// string agent_id = 2;
inline void HeartBeatRequest::clear_agent_id() {
  _impl_.agent_id_.ClearToEmpty();
}
inline const std::string& HeartBeatRequest::agent_id() const {
  // @@protoc_insertion_point(field_get:configserver.proto.HeartBeatRequest.agent_id)
  return _internal_agent_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void HeartBeatRequest::set_agent_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.agent_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:configserver.proto.HeartBeatRequest.agent_id)
}
inline std::string* HeartBeatRequest::mutable_agent_id() {
  std::string* _s = _internal_mutable_agent_id();
  // @@protoc_insertion_point(field_mutable:configserver.proto.HeartBeatRequest.agent_id)
  return _s;
}
inline const std::string& HeartBeatRequest::_internal_agent_id() const {
  return _impl_.agent_id_.Get();
}
inline void HeartBeatRequest::_internal_set_agent_id(const std::string& value) {
  
  _impl_.agent_id_.Set(value, GetArenaForAllocation());
}
inline std::string* HeartBeatRequest::_internal_mutable_agent_id() {
  
  return _impl_.agent_id_.Mutable(GetArenaForAllocation());
}
inline std::string* HeartBeatRequest::release_agent_id() {
  // @@protoc_insertion_point(field_release:configserver.proto.HeartBeatRequest.agent_id)
  return _impl_.agent_id_.Release();
}
inline void HeartBeatRequest::set_allocated_agent_id(std::string* agent_id) {
  if (agent_id != nullptr) {
    
  } else {
    
  }
  _impl_.agent_id_.SetAllocated(agent_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.agent_id_.IsDefault()) {
    _impl_.agent_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:configserver.proto.HeartBeatRequest.agent_id)
}

// string agent_type = 3;
inline void HeartBeatRequest::clear_agent_type() {
  _impl_.agent_type_.ClearToEmpty();
}
inline const std::string& HeartBeatRequest::agent_type() const {
  // @@protoc_insertion_point(field_get:configserver.proto.HeartBeatRequest.agent_type)
  return _internal_agent_type();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void HeartBeatRequest::set_agent_type(ArgT0&& arg0, ArgT... args) {
 
 _impl_.agent_type_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:configserver.proto.HeartBeatRequest.agent_type)
}
inline std::string* HeartBeatRequest::mutable_agent_type() {
  std::string* _s = _internal_mutable_agent_type();
  // @@protoc_insertion_point(field_mutable:configserver.proto.HeartBeatRequest.agent_type)
  return _s;
}
inline const std::string& HeartBeatRequest::_internal_agent_type() const {
  return _impl_.agent_type_.Get();
}
inline void HeartBeatRequest::_internal_set_agent_type(const std::string& value) {
  
  _impl_.agent_type_.Set(value, GetArenaForAllocation());
}
inline std::string* HeartBeatRequest::_internal_mutable_agent_type() {
  
  return _impl_.agent_type_.Mutable(GetArenaForAllocation());
}
inline std::string* HeartBeatRequest::release_agent_type() {
  // @@protoc_insertion_point(field_release:configserver.proto.HeartBeatRequest.agent_type)
  return _impl_.agent_type_.Release();
}
inline void HeartBeatRequest::set_allocated_agent_type(std::string* agent_type) {
  if (agent_type != nullptr) {
    
  } else {
    
  }
  _impl_.agent_type_.SetAllocated(agent_type, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.agent_type_.IsDefault()) {
    _impl_.agent_type_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:configserver.proto.HeartBeatRequest.agent_type)
}

// string agent_version = 4;
inline void HeartBeatRequest::clear_agent_version() {
  _impl_.agent_version_.ClearToEmpty();
}
inline const std::string& HeartBeatRequest::agent_version() const {
  // @@protoc_insertion_point(field_get:configserver.proto.HeartBeatRequest.agent_version)
  return _internal_agent_version();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void HeartBeatRequest::set_agent_version(ArgT0&& arg0, ArgT... args) {
 
 _impl_.agent_version_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:configserver.proto.HeartBeatRequest.agent_version)
}
inline std::string* HeartBeatRequest::mutable_agent_version() {
  std::string* _s = _internal_mutable_agent_version();
  // @@protoc_insertion_point(field_mutable:configserver.proto.HeartBeatRequest.agent_version)
  return _s;
}
inline const std::string& HeartBeatRequest::_internal_agent_version() const {
  return _impl_.agent_version_.Get();
}
inline void HeartBeatRequest::_internal_set_agent_version(const std::string& value) {
  
  _impl_.agent_version_.Set(value, GetArenaForAllocation());
}
inline std::string* HeartBeatRequest::_internal_mutable_agent_version() {
  
  return _impl_.agent_version_.Mutable(GetArenaForAllocation());
}
inline std::string* HeartBeatRequest::release_agent_version() {
  // @@protoc_insertion_point(field_release:configserver.proto.HeartBeatRequest.agent_version)
  return _impl_.agent_version_.Release();
}
inline void HeartBeatRequest::set_allocated_agent_version(std::string* agent_version) {
  if (agent_version != nullptr) {
    
  } else {
    
  }
  _impl_.agent_version_.SetAllocated(agent_version, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.agent_version_.IsDefault()) {
    _impl_.agent_version_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:configserver.proto.HeartBeatRequest.agent_version)
}

// string ip = 5;
inline void HeartBeatRequest::clear_ip() {
  _impl_.ip_.ClearToEmpty();
}
inline const std::string& HeartBeatRequest::ip() const {
  // @@protoc_insertion_point(field_get:configserver.proto.HeartBeatRequest.ip)
  return _internal_ip();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void HeartBeatRequest::set_ip(ArgT0&& arg0, ArgT... args) {
 
 _impl_.ip_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:configserver.proto.HeartBeatRequest.ip)
}
inline std::string* HeartBeatRequest::mutable_ip() {
  std::string* _s = _internal_mutable_ip();
  // @@protoc_insertion_point(field_mutable:configserver.proto.HeartBeatRequest.ip)
  return _s;
}
inline const std::string& HeartBeatRequest::_internal_ip() const {
  return _impl_.ip_.Get();
}
inline void HeartBeatRequest::_internal_set_ip(const std::string& value) {
  
  _impl_.ip_.Set(value, GetArenaForAllocation());
}
inline std::string* HeartBeatRequest::_internal_mutable_ip() {
  
  return _impl_.ip_.Mutable(GetArenaForAllocation());
}
inline std::string* HeartBeatRequest::release_ip() {
  // @@protoc_insertion_point(field_release:configserver.proto.HeartBeatRequest.ip)
  return _impl_.ip_.Release();
}
inline void HeartBeatRequest::set_allocated_ip(std::string* ip) {
  if (ip != nullptr) {
    
  } else {
    
  }
  _impl_.ip_.SetAllocated(ip, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.ip_.IsDefault()) {
    _impl_.ip_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:configserver.proto.HeartBeatRequest.ip)
}

// map<string, string> tags = 6;
inline int HeartBeatRequest::_internal_tags_size() const {
  return _impl_.tags_.size();
}
inline int HeartBeatRequest::tags_size() const {
  return _internal_tags_size();
}
inline void HeartBeatRequest::clear_tags() {
  _impl_.tags_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
HeartBeatRequest::_internal_tags() const {
  return _impl_.tags_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
HeartBeatRequest::tags() const {
  // @@protoc_insertion_point(field_map:configserver.proto.HeartBeatRequest.tags)
  return _internal_tags();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
HeartBeatRequest::_internal_mutable_tags() {
  return _impl_.tags_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
HeartBeatRequest::mutable_tags() {
  // @@protoc_insertion_point(field_mutable_map:configserver.proto.HeartBeatRequest.tags)
  return _internal_mutable_tags();
}

// string running_status = 7;
inline void HeartBeatRequest::clear_running_status() {
  _impl_.running_status_.ClearToEmpty();
}
inline const std::string& HeartBeatRequest::running_status() const {
  // @@protoc_insertion_point(field_get:configserver.proto.HeartBeatRequest.running_status)
  return _internal_running_status();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void HeartBeatRequest::set_running_status(ArgT0&& arg0, ArgT... args) {
 
 _impl_.running_status_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:configserver.proto.HeartBeatRequest.running_status)
}
inline std::string* HeartBeatRequest::mutable_running_status() {
  std::string* _s = _internal_mutable_running_status();
  // @@protoc_insertion_point(field_mutable:configserver.proto.HeartBeatRequest.running_status)
  return _s;
}
inline const std::string& HeartBeatRequest::_internal_running_status() const {
  return _impl_.running_status_.Get();
}
inline void HeartBeatRequest::_internal_set_running_status(const std::string& value) {
  
  _impl_.running_status_.Set(value, GetArenaForAllocation());
}
inline std::string* HeartBeatRequest::_internal_mutable_running_status() {
  
  return _impl_.running_status_.Mutable(GetArenaForAllocation());
}
inline std::string* HeartBeatRequest::release_running_status() {
  // @@protoc_insertion_point(field_release:configserver.proto.HeartBeatRequest.running_status)
  return _impl_.running_status_.Release();
}
inline void HeartBeatRequest::set_allocated_running_status(std::string* running_status) {
  if (running_status != nullptr) {
    
  } else {
    
  }
  _impl_.running_status_.SetAllocated(running_status, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.running_status_.IsDefault()) {
    _impl_.running_status_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:configserver.proto.HeartBeatRequest.running_status)
}

// int64 startup_time = 8;
inline void HeartBeatRequest::clear_startup_time() {
  _impl_.startup_time_ = int64_t{0};
}
inline int64_t HeartBeatRequest::_internal_startup_time() const {
  return _impl_.startup_time_;
}
inline int64_t HeartBeatRequest::startup_time() const {
  // @@protoc_insertion_point(field_get:configserver.proto.HeartBeatRequest.startup_time)
  return _internal_startup_time();
}
inline void HeartBeatRequest::_internal_set_startup_time(int64_t value) {
  
  _impl_.startup_time_ = value;
}
inline void HeartBeatRequest::set_startup_time(int64_t value) {
  _internal_set_startup_time(value);
  // @@protoc_insertion_point(field_set:configserver.proto.HeartBeatRequest.startup_time)
}

// -------------------------------------------------------------------

// HeartBeatResponse

// string response_id = 1;
inline void HeartBeatResponse::clear_response_id() {
  _impl_.response_id_.ClearToEmpty();
}
inline const std::string& HeartBeatResponse::response_id() const {
  // @@protoc_insertion_point(field_get:configserver.proto.HeartBeatResponse.response_id)
  return _internal_response_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void HeartBeatResponse::set_response_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.response_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:configserver.proto.HeartBeatResponse.response_id)
}
inline std::string* HeartBeatResponse::mutable_response_id() {
  std::string* _s = _internal_mutable_response_id();
  // @@protoc_insertion_point(field_mutable:configserver.proto.HeartBeatResponse.response_id)
  return _s;
}
inline const std::string& HeartBeatResponse::_internal_response_id() const {
  return _impl_.response_id_.Get();
}
inline void HeartBeatResponse::_internal_set_response_id(const std::string& value) {
  
  _impl_.response_id_.Set(value, GetArenaForAllocation());
}
inline std::string* HeartBeatResponse::_internal_mutable_response_id() {
  
  return _impl_.response_id_.Mutable(GetArenaForAllocation());
}
inline std::string* HeartBeatResponse::release_response_id() {
  // @@protoc_insertion_point(field_release:configserver.proto.HeartBeatResponse.response_id)
  return _impl_.response_id_.Release();
}
inline void HeartBeatResponse::set_allocated_response_id(std::string* response_id) {
  if (response_id != nullptr) {
    
  } else {
    
  }
  _impl_.response_id_.SetAllocated(response_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.response_id_.IsDefault()) {
    _impl_.response_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:configserver.proto.HeartBeatResponse.response_id)
}

// string code = 2;
inline void HeartBeatResponse::clear_code() {
  _impl_.code_.ClearToEmpty();
}
inline const std::string& HeartBeatResponse::code() const {
  // @@protoc_insertion_point(field_get:configserver.proto.HeartBeatResponse.code)
  return _internal_code();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void HeartBeatResponse::set_code(ArgT0&& arg0, ArgT... args) {
 
 _impl_.code_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:configserver.proto.HeartBeatResponse.code)
}
inline std::string* HeartBeatResponse::mutable_code() {
  std::string* _s = _internal_mutable_code();
  // @@protoc_insertion_point(field_mutable:configserver.proto.HeartBeatResponse.code)
  return _s;
}
inline const std::string& HeartBeatResponse::_internal_code() const {
  return _impl_.code_.Get();
}
inline void HeartBeatResponse::_internal_set_code(const std::string& value) {
  
  _impl_.code_.Set(value, GetArenaForAllocation());
}
inline std::string* HeartBeatResponse::_internal_mutable_code() {
  
  return _impl_.code_.Mutable(GetArenaForAllocation());
}
inline std::string* HeartBeatResponse::release_code() {
  // @@protoc_insertion_point(field_release:configserver.proto.HeartBeatResponse.code)
  return _impl_.code_.Release();
}
inline void HeartBeatResponse::set_allocated_code(std::string* code) {
  if (code != nullptr) {
    
  } else {
    
  }
  _impl_.code_.SetAllocated(code, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.code_.IsDefault()) {
    _impl_.code_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:configserver.proto.HeartBeatResponse.code)
}

// string message = 3;
inline void HeartBeatResponse::clear_message() {
  _impl_.message_.ClearToEmpty();
}
inline const std::string& HeartBeatResponse::message() const {
  // @@protoc_insertion_point(field_get:configserver.proto.HeartBeatResponse.message)
  return _internal_message();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void HeartBeatResponse::set_message(ArgT0&& arg0, ArgT... args) {
 
 _impl_.message_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:configserver.proto.HeartBeatResponse.message)
}
inline std::string* HeartBeatResponse::mutable_message() {
  std::string* _s = _internal_mutable_message();
  // @@protoc_insertion_point(field_mutable:configserver.proto.HeartBeatResponse.message)
  return _s;
}
inline const std::string& HeartBeatResponse::_internal_message() const {
  return _impl_.message_.Get();
}
inline void HeartBeatResponse::_internal_set_message(const std::string& value) {
  
  _impl_.message_.Set(value, GetArenaForAllocation());
}
inline std::string* HeartBeatResponse::_internal_mutable_message() {
  
  return _impl_.message_.Mutable(GetArenaForAllocation());
}
inline std::string* HeartBeatResponse::release_message() {
  // @@protoc_insertion_point(field_release:configserver.proto.HeartBeatResponse.message)
  return _impl_.message_.Release();
}
inline void HeartBeatResponse::set_allocated_message(std::string* message) {
  if (message != nullptr) {
    
  } else {
    
  }
  _impl_.message_.SetAllocated(message, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.message_.IsDefault()) {
    _impl_.message_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:configserver.proto.HeartBeatResponse.message)
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// RunningStatistics

// float cpu = 1;
inline void RunningStatistics::clear_cpu() {
  _impl_.cpu_ = 0;
}
inline float RunningStatistics::_internal_cpu() const {
  return _impl_.cpu_;
}
inline float RunningStatistics::cpu() const {
  // @@protoc_insertion_point(field_get:configserver.proto.RunningStatistics.cpu)
  return _internal_cpu();
}
inline void RunningStatistics::_internal_set_cpu(float value) {
  
  _impl_.cpu_ = value;
}
inline void RunningStatistics::set_cpu(float value) {
  _internal_set_cpu(value);
  // @@protoc_insertion_point(field_set:configserver.proto.RunningStatistics.cpu)
}

// int64 memory = 2;
inline void RunningStatistics::clear_memory() {
  _impl_.memory_ = int64_t{0};
}
inline int64_t RunningStatistics::_internal_memory() const {
  return _impl_.memory_;
}
inline int64_t RunningStatistics::memory() const {
  // @@protoc_insertion_point(field_get:configserver.proto.RunningStatistics.memory)
  return _internal_memory();
}
inline void RunningStatistics::_internal_set_memory(int64_t value) {
  
  _impl_.memory_ = value;
}
inline void RunningStatistics::set_memory(int64_t value) {
  _internal_set_memory(value);
  // @@protoc_insertion_point(field_set:configserver.proto.RunningStatistics.memory)
}

// map<string, string> extras = 100;
inline int RunningStatistics::_internal_extras_size() const {
  return _impl_.extras_.size();
}
inline int RunningStatistics::extras_size() const {
  return _internal_extras_size();
}
inline void RunningStatistics::clear_extras() {
  _impl_.extras_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
RunningStatistics::_internal_extras() const {
  return _impl_.extras_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
RunningStatistics::extras() const {
  // @@protoc_insertion_point(field_map:configserver.proto.RunningStatistics.extras)
  return _internal_extras();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
RunningStatistics::_internal_mutable_extras() {
  return _impl_.extras_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
RunningStatistics::mutable_extras() {
  // @@protoc_insertion_point(field_mutable_map:configserver.proto.RunningStatistics.extras)
  return _internal_mutable_extras();
}

// -------------------------------------------------------------------

// RunningStatisticsRequest

// string request_id = 1;
inline void RunningStatisticsRequest::clear_request_id() {
  _impl_.request_id_.ClearToEmpty();
}
inline const std::string& RunningStatisticsRequest::request_id() const {
  // @@protoc_insertion_point(field_get:configserver.proto.RunningStatisticsRequest.request_id)
  return _internal_request_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void RunningStatisticsRequest::set_request_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.request_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:configserver.proto.RunningStatisticsRequest.request_id)
}
inline std::string* RunningStatisticsRequest::mutable_request_id() {
  std::string* _s = _internal_mutable_request_id();
  // @@protoc_insertion_point(field_mutable:configserver.proto.RunningStatisticsRequest.request_id)
  return _s;
}
inline const std::string& RunningStatisticsRequest::_internal_request_id() const {
  return _impl_.request_id_.Get();
}
inline void RunningStatisticsRequest::_internal_set_request_id(const std::string& value) {
  
  _impl_.request_id_.Set(value, GetArenaForAllocation());
}
inline std::string* RunningStatisticsRequest::_internal_mutable_request_id() {
  
  return _impl_.request_id_.Mutable(GetArenaForAllocation());
}
inline std::string* RunningStatisticsRequest::release_request_id() {
  // @@protoc_insertion_point(field_release:configserver.proto.RunningStatisticsRequest.request_id)
  return _impl_.request_id_.Release();
}
inline void RunningStatisticsRequest::set_allocated_request_id(std::string* request_id) {
  if (request_id != nullptr) {
    
  } else {
    
  }
  _impl_.request_id_.SetAllocated(request_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.request_id_.IsDefault()) {
    _impl_.request_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:configserver.proto.RunningStatisticsRequest.request_id)
}

// string agent_id = 2;
inline void RunningStatisticsRequest::clear_agent_id() {
  _impl_.agent_id_.ClearToEmpty();
}
inline const std::string& RunningStatisticsRequest::agent_id() const {
  // @@protoc_insertion_point(field_get:configserver.proto.RunningStatisticsRequest.agent_id)
  return _internal_agent_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void RunningStatisticsRequest::set_agent_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.agent_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:configserver.proto.RunningStatisticsRequest.agent_id)
}
inline std::string* RunningStatisticsRequest::mutable_agent_id() {
  std::string* _s = _internal_mutable_agent_id();
  // @@protoc_insertion_point(field_mutable:configserver.proto.RunningStatisticsRequest.agent_id)
  return _s;
}
inline const std::string& RunningStatisticsRequest::_internal_agent_id() const {
  return _impl_.agent_id_.Get();
}
inline void RunningStatisticsRequest::_internal_set_agent_id(const std::string& value) {
  
  _impl_.agent_id_.Set(value, GetArenaForAllocation());
}
inline std::string* RunningStatisticsRequest::_internal_mutable_agent_id() {
  
  return _impl_.agent_id_.Mutable(GetArenaForAllocation());
}
inline std::string* RunningStatisticsRequest::release_agent_id() {
  // @@protoc_insertion_point(field_release:configserver.proto.RunningStatisticsRequest.agent_id)
  return _impl_.agent_id_.Release();
}
inline void RunningStatisticsRequest::set_allocated_agent_id(std::string* agent_id) {
  if (agent_id != nullptr) {
    
  } else {
    
  }
  _impl_.agent_id_.SetAllocated(agent_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.agent_id_.IsDefault()) {
    _impl_.agent_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:configserver.proto.RunningStatisticsRequest.agent_id)
}

// .configserver.proto.RunningStatistics running_details = 3;
inline bool RunningStatisticsRequest::_internal_has_running_details() const {
  return this != internal_default_instance() && _impl_.running_details_ != nullptr;
}
inline bool RunningStatisticsRequest::has_running_details() const {
  return _internal_has_running_details();
}
inline void RunningStatisticsRequest::clear_running_details() {
  if (GetArenaForAllocation() == nullptr && _impl_.running_details_ != nullptr) {
    delete _impl_.running_details_;
  }
  _impl_.running_details_ = nullptr;
}
inline const ::configserver::proto::RunningStatistics& RunningStatisticsRequest::_internal_running_details() const {
  const ::configserver::proto::RunningStatistics* p = _impl_.running_details_;
  return p != nullptr ? *p : reinterpret_cast<const ::configserver::proto::RunningStatistics&>(
      ::configserver::proto::_RunningStatistics_default_instance_);
}
inline const ::configserver::proto::RunningStatistics& RunningStatisticsRequest::running_details() const {
  // @@protoc_insertion_point(field_get:configserver.proto.RunningStatisticsRequest.running_details)
  return _internal_running_details();
}
inline void RunningStatisticsRequest::unsafe_arena_set_allocated_running_details(
    ::configserver::proto::RunningStatistics* running_details) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.running_details_);
  }
  _impl_.running_details_ = running_details;
  if (running_details) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:configserver.proto.RunningStatisticsRequest.running_details)
}
inline ::configserver::proto::RunningStatistics* RunningStatisticsRequest::release_running_details() {
  
  ::configserver::proto::RunningStatistics* temp = _impl_.running_details_;
  _impl_.running_details_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::configserver::proto::RunningStatistics* RunningStatisticsRequest::unsafe_arena_release_running_details() {
  // @@protoc_insertion_point(field_release:configserver.proto.RunningStatisticsRequest.running_details)
  
  ::configserver::proto::RunningStatistics* temp = _impl_.running_details_;
  _impl_.running_details_ = nullptr;
  return temp;
}
inline ::configserver::proto::RunningStatistics* RunningStatisticsRequest::_internal_mutable_running_details() {
  
  if (_impl_.running_details_ == nullptr) {
    auto* p = CreateMaybeMessage<::configserver::proto::RunningStatistics>(GetArenaForAllocation());
    _impl_.running_details_ = p;
  }
  return _impl_.running_details_;
}
inline ::configserver::proto::RunningStatistics* RunningStatisticsRequest::mutable_running_details() {
  ::configserver::proto::RunningStatistics* _msg = _internal_mutable_running_details();
  // @@protoc_insertion_point(field_mutable:configserver.proto.RunningStatisticsRequest.running_details)
  return _msg;
}
inline void RunningStatisticsRequest::set_allocated_running_details(::configserver::proto::RunningStatistics* running_details) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.running_details_;
  }
  if (running_details) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(running_details);
    if (message_arena != submessage_arena) {
      running_details = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, running_details, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.running_details_ = running_details;
  // @@protoc_insertion_point(field_set_allocated:configserver.proto.RunningStatisticsRequest.running_details)
}

// -------------------------------------------------------------------

// RunningStatisticsResponse

// string response_id = 1;
inline void RunningStatisticsResponse::clear_response_id() {
  _impl_.response_id_.ClearToEmpty();
}
inline const std::string& RunningStatisticsResponse::response_id() const {
  // @@protoc_insertion_point(field_get:configserver.proto.RunningStatisticsResponse.response_id)
  return _internal_response_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void RunningStatisticsResponse::set_response_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.response_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:configserver.proto.RunningStatisticsResponse.response_id)
}
inline std::string* RunningStatisticsResponse::mutable_response_id() {
  std::string* _s = _internal_mutable_response_id();
  // @@protoc_insertion_point(field_mutable:configserver.proto.RunningStatisticsResponse.response_id)
  return _s;
}
inline const std::string& RunningStatisticsResponse::_internal_response_id() const {
  return _impl_.response_id_.Get();
}
inline void RunningStatisticsResponse::_internal_set_response_id(const std::string& value) {
  
  _impl_.response_id_.Set(value, GetArenaForAllocation());
}
inline std::string* RunningStatisticsResponse::_internal_mutable_response_id() {
  
  return _impl_.response_id_.Mutable(GetArenaForAllocation());
}
inline std::string* RunningStatisticsResponse::release_response_id() {
  // @@protoc_insertion_point(field_release:configserver.proto.RunningStatisticsResponse.response_id)
  return _impl_.response_id_.Release();
}
inline void RunningStatisticsResponse::set_allocated_response_id(std::string* response_id) {
  if (response_id != nullptr) {
    
  } else {
    
  }
  _impl_.response_id_.SetAllocated(response_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.response_id_.IsDefault()) {
    _impl_.response_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:configserver.proto.RunningStatisticsResponse.response_id)
}

// string code = 2;
inline void RunningStatisticsResponse::clear_code() {
  _impl_.code_.ClearToEmpty();
}
inline const std::string& RunningStatisticsResponse::code() const {
  // @@protoc_insertion_point(field_get:configserver.proto.RunningStatisticsResponse.code)
  return _internal_code();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void RunningStatisticsResponse::set_code(ArgT0&& arg0, ArgT... args) {
 
 _impl_.code_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:configserver.proto.RunningStatisticsResponse.code)
}
inline std::string* RunningStatisticsResponse::mutable_code() {
  std::string* _s = _internal_mutable_code();
  // @@protoc_insertion_point(field_mutable:configserver.proto.RunningStatisticsResponse.code)
  return _s;
}
inline const std::string& RunningStatisticsResponse::_internal_code() const {
  return _impl_.code_.Get();
}
inline void RunningStatisticsResponse::_internal_set_code(const std::string& value) {
  
  _impl_.code_.Set(value, GetArenaForAllocation());
}
inline std::string* RunningStatisticsResponse::_internal_mutable_code() {
  
  return _impl_.code_.Mutable(GetArenaForAllocation());
}
inline std::string* RunningStatisticsResponse::release_code() {
  // @@protoc_insertion_point(field_release:configserver.proto.RunningStatisticsResponse.code)
  return _impl_.code_.Release();
}
inline void RunningStatisticsResponse::set_allocated_code(std::string* code) {
  if (code != nullptr) {
    
  } else {
    
  }
  _impl_.code_.SetAllocated(code, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.code_.IsDefault()) {
    _impl_.code_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:configserver.proto.RunningStatisticsResponse.code)
}

// string message = 3;
inline void RunningStatisticsResponse::clear_message() {
  _impl_.message_.ClearToEmpty();
}
inline const std::string& RunningStatisticsResponse::message() const {
  // @@protoc_insertion_point(field_get:configserver.proto.RunningStatisticsResponse.message)
  return _internal_message();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void RunningStatisticsResponse::set_message(ArgT0&& arg0, ArgT... args) {
 
 _impl_.message_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:configserver.proto.RunningStatisticsResponse.message)
}
inline std::string* RunningStatisticsResponse::mutable_message() {
  std::string* _s = _internal_mutable_message();
  // @@protoc_insertion_point(field_mutable:configserver.proto.RunningStatisticsResponse.message)
  return _s;
}
inline const std::string& RunningStatisticsResponse::_internal_message() const {
  return _impl_.message_.Get();
}
inline void RunningStatisticsResponse::_internal_set_message(const std::string& value) {
  
  _impl_.message_.Set(value, GetArenaForAllocation());
}
inline std::string* RunningStatisticsResponse::_internal_mutable_message() {
  
  return _impl_.message_.Mutable(GetArenaForAllocation());
}
inline std::string* RunningStatisticsResponse::release_message() {
  // @@protoc_insertion_point(field_release:configserver.proto.RunningStatisticsResponse.message)
  return _impl_.message_.Release();
}
inline void RunningStatisticsResponse::set_allocated_message(std::string* message) {
  if (message != nullptr) {
    
  } else {
    
  }
  _impl_.message_.SetAllocated(message, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.message_.IsDefault()) {
    _impl_.message_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:configserver.proto.RunningStatisticsResponse.message)
}

// -------------------------------------------------------------------

// AlarmRequest

// string request_id = 1;
inline void AlarmRequest::clear_request_id() {
  _impl_.request_id_.ClearToEmpty();
}
inline const std::string& AlarmRequest::request_id() const {
  // @@protoc_insertion_point(field_get:configserver.proto.AlarmRequest.request_id)
  return _internal_request_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void AlarmRequest::set_request_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.request_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:configserver.proto.AlarmRequest.request_id)
}
inline std::string* AlarmRequest::mutable_request_id() {
  std::string* _s = _internal_mutable_request_id();
  // @@protoc_insertion_point(field_mutable:configserver.proto.AlarmRequest.request_id)
  return _s;
}
inline const std::string& AlarmRequest::_internal_request_id() const {
  return _impl_.request_id_.Get();
}
inline void AlarmRequest::_internal_set_request_id(const std::string& value) {
  
  _impl_.request_id_.Set(value, GetArenaForAllocation());
}
inline std::string* AlarmRequest::_internal_mutable_request_id() {
  
  return _impl_.request_id_.Mutable(GetArenaForAllocation());
}
inline std::string* AlarmRequest::release_request_id() {
  // @@protoc_insertion_point(field_release:configserver.proto.AlarmRequest.request_id)
  return _impl_.request_id_.Release();
}
inline void AlarmRequest::set_allocated_request_id(std::string* request_id) {
  if (request_id != nullptr) {
    
  } else {
    
  }
  _impl_.request_id_.SetAllocated(request_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.request_id_.IsDefault()) {
    _impl_.request_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:configserver.proto.AlarmRequest.request_id)
}

// string agent_id = 2;
inline void AlarmRequest::clear_agent_id() {
  _impl_.agent_id_.ClearToEmpty();
}
inline const std::string& AlarmRequest::agent_id() const {
  // @@protoc_insertion_point(field_get:configserver.proto.AlarmRequest.agent_id)
  return _internal_agent_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void AlarmRequest::set_agent_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.agent_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:configserver.proto.AlarmRequest.agent_id)
}
inline std::string* AlarmRequest::mutable_agent_id() {
  std::string* _s = _internal_mutable_agent_id();
  // @@protoc_insertion_point(field_mutable:configserver.proto.AlarmRequest.agent_id)
  return _s;
}
inline const std::string& AlarmRequest::_internal_agent_id() const {
  return _impl_.agent_id_.Get();
}
inline void AlarmRequest::_internal_set_agent_id(const std::string& value) {
  
  _impl_.agent_id_.Set(value, GetArenaForAllocation());
}
inline std::string* AlarmRequest::_internal_mutable_agent_id() {
  
  return _impl_.agent_id_.Mutable(GetArenaForAllocation());
}
inline std::string* AlarmRequest::release_agent_id() {
  // @@protoc_insertion_point(field_release:configserver.proto.AlarmRequest.agent_id)
  return _impl_.agent_id_.Release();
}
inline void AlarmRequest::set_allocated_agent_id(std::string* agent_id) {
  if (agent_id != nullptr) {
    
  } else {
    
  }
  _impl_.agent_id_.SetAllocated(agent_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.agent_id_.IsDefault()) {
    _impl_.agent_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:configserver.proto.AlarmRequest.agent_id)
}

// string type = 3;
inline void AlarmRequest::clear_type() {
  _impl_.type_.ClearToEmpty();
}
inline const std::string& AlarmRequest::type() const {
  // @@protoc_insertion_point(field_get:configserver.proto.AlarmRequest.type)
  return _internal_type();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void AlarmRequest::set_type(ArgT0&& arg0, ArgT... args) {
 
 _impl_.type_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:configserver.proto.AlarmRequest.type)
}
inline std::string* AlarmRequest::mutable_type() {
  std::string* _s = _internal_mutable_type();
  // @@protoc_insertion_point(field_mutable:configserver.proto.AlarmRequest.type)
  return _s;
}
inline const std::string& AlarmRequest::_internal_type() const {
  return _impl_.type_.Get();
}
inline void AlarmRequest::_internal_set_type(const std::string& value) {
  
  _impl_.type_.Set(value, GetArenaForAllocation());
}
inline std::string* AlarmRequest::_internal_mutable_type() {
  
  return _impl_.type_.Mutable(GetArenaForAllocation());
}
inline std::string* AlarmRequest::release_type() {
  // @@protoc_insertion_point(field_release:configserver.proto.AlarmRequest.type)
  return _impl_.type_.Release();
}
inline void AlarmRequest::set_allocated_type(std::string* type) {
  if (type != nullptr) {
    
  } else {
    
  }
  _impl_.type_.SetAllocated(type, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.type_.IsDefault()) {
    _impl_.type_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:configserver.proto.AlarmRequest.type)
}

// string detail = 4;
inline void AlarmRequest::clear_detail() {
  _impl_.detail_.ClearToEmpty();
}
inline const std::string& AlarmRequest::detail() const {
  // @@protoc_insertion_point(field_get:configserver.proto.AlarmRequest.detail)
  return _internal_detail();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void AlarmRequest::set_detail(ArgT0&& arg0, ArgT... args) {
 
 _impl_.detail_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:configserver.proto.AlarmRequest.detail)
}
inline std::string* AlarmRequest::mutable_detail() {
  std::string* _s = _internal_mutable_detail();
  // @@protoc_insertion_point(field_mutable:configserver.proto.AlarmRequest.detail)
  return _s;
}
inline const std::string& AlarmRequest::_internal_detail() const {
  return _impl_.detail_.Get();
}
inline void AlarmRequest::_internal_set_detail(const std::string& value) {
  
  _impl_.detail_.Set(value, GetArenaForAllocation());
}
inline std::string* AlarmRequest::_internal_mutable_detail() {
  
  return _impl_.detail_.Mutable(GetArenaForAllocation());
}
inline std::string* AlarmRequest::release_detail() {
  // @@protoc_insertion_point(field_release:configserver.proto.AlarmRequest.detail)
  return _impl_.detail_.Release();
}
inline void AlarmRequest::set_allocated_detail(std::string* detail) {
  if (detail != nullptr) {
    
  } else {
    
  }
  _impl_.detail_.SetAllocated(detail, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.detail_.IsDefault()) {
    _impl_.detail_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:configserver.proto.AlarmRequest.detail)
}

// -------------------------------------------------------------------

// AlarmResponse

// string response_id = 1;
inline void AlarmResponse::clear_response_id() {
  _impl_.response_id_.ClearToEmpty();
}
inline const std::string& AlarmResponse::response_id() const {
  // @@protoc_insertion_point(field_get:configserver.proto.AlarmResponse.response_id)
  return _internal_response_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void AlarmResponse::set_response_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.response_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:configserver.proto.AlarmResponse.response_id)
}
inline std::string* AlarmResponse::mutable_response_id() {
  std::string* _s = _internal_mutable_response_id();
  // @@protoc_insertion_point(field_mutable:configserver.proto.AlarmResponse.response_id)
  return _s;
}
inline const std::string& AlarmResponse::_internal_response_id() const {
  return _impl_.response_id_.Get();
}
inline void AlarmResponse::_internal_set_response_id(const std::string& value) {
  
  _impl_.response_id_.Set(value, GetArenaForAllocation());
}
inline std::string* AlarmResponse::_internal_mutable_response_id() {
  
  return _impl_.response_id_.Mutable(GetArenaForAllocation());
}
inline std::string* AlarmResponse::release_response_id() {
  // @@protoc_insertion_point(field_release:configserver.proto.AlarmResponse.response_id)
  return _impl_.response_id_.Release();
}
inline void AlarmResponse::set_allocated_response_id(std::string* response_id) {
  if (response_id != nullptr) {
    
  } else {
    
  }
  _impl_.response_id_.SetAllocated(response_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.response_id_.IsDefault()) {
    _impl_.response_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:configserver.proto.AlarmResponse.response_id)
}

// string code = 2;
inline void AlarmResponse::clear_code() {
  _impl_.code_.ClearToEmpty();
}
inline const std::string& AlarmResponse::code() const {
  // @@protoc_insertion_point(field_get:configserver.proto.AlarmResponse.code)
  return _internal_code();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void AlarmResponse::set_code(ArgT0&& arg0, ArgT... args) {
 
 _impl_.code_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:configserver.proto.AlarmResponse.code)
}
inline std::string* AlarmResponse::mutable_code() {
  std::string* _s = _internal_mutable_code();
  // @@protoc_insertion_point(field_mutable:configserver.proto.AlarmResponse.code)
  return _s;
}
inline const std::string& AlarmResponse::_internal_code() const {
  return _impl_.code_.Get();
}
inline void AlarmResponse::_internal_set_code(const std::string& value) {
  
  _impl_.code_.Set(value, GetArenaForAllocation());
}
inline std::string* AlarmResponse::_internal_mutable_code() {
  
  return _impl_.code_.Mutable(GetArenaForAllocation());
}
inline std::string* AlarmResponse::release_code() {
  // @@protoc_insertion_point(field_release:configserver.proto.AlarmResponse.code)
  return _impl_.code_.Release();
}
inline void AlarmResponse::set_allocated_code(std::string* code) {
  if (code != nullptr) {
    
  } else {
    
  }
  _impl_.code_.SetAllocated(code, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.code_.IsDefault()) {
    _impl_.code_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:configserver.proto.AlarmResponse.code)
}

// string message = 3;
inline void AlarmResponse::clear_message() {
  _impl_.message_.ClearToEmpty();
}
inline const std::string& AlarmResponse::message() const {
  // @@protoc_insertion_point(field_get:configserver.proto.AlarmResponse.message)
  return _internal_message();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void AlarmResponse::set_message(ArgT0&& arg0, ArgT... args) {
 
 _impl_.message_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:configserver.proto.AlarmResponse.message)
}
inline std::string* AlarmResponse::mutable_message() {
  std::string* _s = _internal_mutable_message();
  // @@protoc_insertion_point(field_mutable:configserver.proto.AlarmResponse.message)
  return _s;
}
inline const std::string& AlarmResponse::_internal_message() const {
  return _impl_.message_.Get();
}
inline void AlarmResponse::_internal_set_message(const std::string& value) {
  
  _impl_.message_.Set(value, GetArenaForAllocation());
}
inline std::string* AlarmResponse::_internal_mutable_message() {
  
  return _impl_.message_.Mutable(GetArenaForAllocation());
}
inline std::string* AlarmResponse::release_message() {
  // @@protoc_insertion_point(field_release:configserver.proto.AlarmResponse.message)
  return _impl_.message_.Release();
}
inline void AlarmResponse::set_allocated_message(std::string* message) {
  if (message != nullptr) {
    
  } else {
    
  }
  _impl_.message_.SetAllocated(message, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.message_.IsDefault()) {
    _impl_.message_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:configserver.proto.AlarmResponse.message)
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// AgentGetConfigListRequest

// string request_id = 1;
inline void AgentGetConfigListRequest::clear_request_id() {
  _impl_.request_id_.ClearToEmpty();
}
inline const std::string& AgentGetConfigListRequest::request_id() const {
  // @@protoc_insertion_point(field_get:configserver.proto.AgentGetConfigListRequest.request_id)
  return _internal_request_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void AgentGetConfigListRequest::set_request_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.request_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:configserver.proto.AgentGetConfigListRequest.request_id)
}
inline std::string* AgentGetConfigListRequest::mutable_request_id() {
  std::string* _s = _internal_mutable_request_id();
  // @@protoc_insertion_point(field_mutable:configserver.proto.AgentGetConfigListRequest.request_id)
  return _s;
}
inline const std::string& AgentGetConfigListRequest::_internal_request_id() const {
  return _impl_.request_id_.Get();
}
inline void AgentGetConfigListRequest::_internal_set_request_id(const std::string& value) {
  
  _impl_.request_id_.Set(value, GetArenaForAllocation());
}
inline std::string* AgentGetConfigListRequest::_internal_mutable_request_id() {
  
  return _impl_.request_id_.Mutable(GetArenaForAllocation());
}
inline std::string* AgentGetConfigListRequest::release_request_id() {
  // @@protoc_insertion_point(field_release:configserver.proto.AgentGetConfigListRequest.request_id)
  return _impl_.request_id_.Release();
}
inline void AgentGetConfigListRequest::set_allocated_request_id(std::string* request_id) {
  if (request_id != nullptr) {
    
  } else {
    
  }
  _impl_.request_id_.SetAllocated(request_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.request_id_.IsDefault()) {
    _impl_.request_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:configserver.proto.AgentGetConfigListRequest.request_id)
}

// string agent_id = 2;
inline void AgentGetConfigListRequest::clear_agent_id() {
  _impl_.agent_id_.ClearToEmpty();
}
inline const std::string& AgentGetConfigListRequest::agent_id() const {
  // @@protoc_insertion_point(field_get:configserver.proto.AgentGetConfigListRequest.agent_id)
  return _internal_agent_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void AgentGetConfigListRequest::set_agent_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.agent_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:configserver.proto.AgentGetConfigListRequest.agent_id)
}
inline std::string* AgentGetConfigListRequest::mutable_agent_id() {
  std::string* _s = _internal_mutable_agent_id();
  // @@protoc_insertion_point(field_mutable:configserver.proto.AgentGetConfigListRequest.agent_id)
  return _s;
}
inline const std::string& AgentGetConfigListRequest::_internal_agent_id() const {
  return _impl_.agent_id_.Get();
}
inline void AgentGetConfigListRequest::_internal_set_agent_id(const std::string& value) {
  
  _impl_.agent_id_.Set(value, GetArenaForAllocation());
}
inline std::string* AgentGetConfigListRequest::_internal_mutable_agent_id() {
  
  return _impl_.agent_id_.Mutable(GetArenaForAllocation());
}
inline std::string* AgentGetConfigListRequest::release_agent_id() {
  // @@protoc_insertion_point(field_release:configserver.proto.AgentGetConfigListRequest.agent_id)
  return _impl_.agent_id_.Release();
}
inline void AgentGetConfigListRequest::set_allocated_agent_id(std::string* agent_id) {
  if (agent_id != nullptr) {
    
  } else {
    
  }
  _impl_.agent_id_.SetAllocated(agent_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.agent_id_.IsDefault()) {
    _impl_.agent_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:configserver.proto.AgentGetConfigListRequest.agent_id)
}

// map<string, int64> config_versions = 3;
inline int AgentGetConfigListRequest::_internal_config_versions_size() const {
  return _impl_.config_versions_.size();
}
inline int AgentGetConfigListRequest::config_versions_size() const {
  return _internal_config_versions_size();
}
inline void AgentGetConfigListRequest::clear_config_versions() {
  _impl_.config_versions_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, int64_t >&
AgentGetConfigListRequest::_internal_config_versions() const {
  return _impl_.config_versions_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, int64_t >&
AgentGetConfigListRequest::config_versions() const {
  // @@protoc_insertion_point(field_map:configserver.proto.AgentGetConfigListRequest.config_versions)
  return _internal_config_versions();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, int64_t >*
AgentGetConfigListRequest::_internal_mutable_config_versions() {
  return _impl_.config_versions_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, int64_t >*
AgentGetConfigListRequest::mutable_config_versions() {
  // @@protoc_insertion_point(field_mutable_map:configserver.proto.AgentGetConfigListRequest.config_versions)
  return _internal_mutable_config_versions();
}

// map<string, string> tags = 4;
inline int AgentGetConfigListRequest::_internal_tags_size() const {
  return _impl_.tags_.size();
}
inline int AgentGetConfigListRequest::tags_size() const {
  return _internal_tags_size();
}
inline void AgentGetConfigListRequest::clear_tags() {
  _impl_.tags_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
AgentGetConfigListRequest::_internal_tags() const {
  return _impl_.tags_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
AgentGetConfigListRequest::tags() const {
  // @@protoc_insertion_point(field_map:configserver.proto.AgentGetConfigListRequest.tags)
  return _internal_tags();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
AgentGetConfigListRequest::_internal_mutable_tags() {
  return _impl_.tags_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
AgentGetConfigListRequest::mutable_tags() {
  // @@protoc_insertion_point(field_mutable_map:configserver.proto.AgentGetConfigListRequest.tags)
  return _internal_mutable_tags();
}

// -------------------------------------------------------------------

// ConfigUpdateInfo

// string config_name = 1;
inline void ConfigUpdateInfo::clear_config_name() {
  _impl_.config_name_.ClearToEmpty();
}
inline const std::string& ConfigUpdateInfo::config_name() const {
  // @@protoc_insertion_point(field_get:configserver.proto.ConfigUpdateInfo.config_name)
  return _internal_config_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ConfigUpdateInfo::set_config_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.config_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:configserver.proto.ConfigUpdateInfo.config_name)
}
inline std::string* ConfigUpdateInfo::mutable_config_name() {
  std::string* _s = _internal_mutable_config_name();
  // @@protoc_insertion_point(field_mutable:configserver.proto.ConfigUpdateInfo.config_name)
  return _s;
}
inline const std::string& ConfigUpdateInfo::_internal_config_name() const {
  return _impl_.config_name_.Get();
}
inline void ConfigUpdateInfo::_internal_set_config_name(const std::string& value) {
  
  _impl_.config_name_.Set(value, GetArenaForAllocation());
}
inline std::string* ConfigUpdateInfo::_internal_mutable_config_name() {
  
  return _impl_.config_name_.Mutable(GetArenaForAllocation());
}
inline std::string* ConfigUpdateInfo::release_config_name() {
  // @@protoc_insertion_point(field_release:configserver.proto.ConfigUpdateInfo.config_name)
  return _impl_.config_name_.Release();
}
inline void ConfigUpdateInfo::set_allocated_config_name(std::string* config_name) {
  if (config_name != nullptr) {
    
  } else {
    
  }
  _impl_.config_name_.SetAllocated(config_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.config_name_.IsDefault()) {
    _impl_.config_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:configserver.proto.ConfigUpdateInfo.config_name)
}

// .configserver.proto.ConfigUpdateInfo.UpdateStatus update_status = 2;
inline void ConfigUpdateInfo::clear_update_status() {
  _impl_.update_status_ = 0;
}
inline ::configserver::proto::ConfigUpdateInfo_UpdateStatus ConfigUpdateInfo::_internal_update_status() const {
  return static_cast< ::configserver::proto::ConfigUpdateInfo_UpdateStatus >(_impl_.update_status_);
}
inline ::configserver::proto::ConfigUpdateInfo_UpdateStatus ConfigUpdateInfo::update_status() const {
  // @@protoc_insertion_point(field_get:configserver.proto.ConfigUpdateInfo.update_status)
  return _internal_update_status();
}
inline void ConfigUpdateInfo::_internal_set_update_status(::configserver::proto::ConfigUpdateInfo_UpdateStatus value) {
  
  _impl_.update_status_ = value;
}
inline void ConfigUpdateInfo::set_update_status(::configserver::proto::ConfigUpdateInfo_UpdateStatus value) {
  _internal_set_update_status(value);
  // @@protoc_insertion_point(field_set:configserver.proto.ConfigUpdateInfo.update_status)
}

// int64 config_version = 3;
inline void ConfigUpdateInfo::clear_config_version() {
  _impl_.config_version_ = int64_t{0};
}
inline int64_t ConfigUpdateInfo::_internal_config_version() const {
  return _impl_.config_version_;
}
inline int64_t ConfigUpdateInfo::config_version() const {
  // @@protoc_insertion_point(field_get:configserver.proto.ConfigUpdateInfo.config_version)
  return _internal_config_version();
}
inline void ConfigUpdateInfo::_internal_set_config_version(int64_t value) {
  
  _impl_.config_version_ = value;
}
inline void ConfigUpdateInfo::set_config_version(int64_t value) {
  _internal_set_config_version(value);
  // @@protoc_insertion_point(field_set:configserver.proto.ConfigUpdateInfo.config_version)
}

// string content = 4;
inline void ConfigUpdateInfo::clear_content() {
  _impl_.content_.ClearToEmpty();
}
inline const std::string& ConfigUpdateInfo::content() const {
  // @@protoc_insertion_point(field_get:configserver.proto.ConfigUpdateInfo.content)
  return _internal_content();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ConfigUpdateInfo::set_content(ArgT0&& arg0, ArgT... args) {
 
 _impl_.content_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:configserver.proto.ConfigUpdateInfo.content)
}
inline std::string* ConfigUpdateInfo::mutable_content() {
  std::string* _s = _internal_mutable_content();
  // @@protoc_insertion_point(field_mutable:configserver.proto.ConfigUpdateInfo.content)
  return _s;
}
inline const std::string& ConfigUpdateInfo::_internal_content() const {
  return _impl_.content_.Get();
}
inline void ConfigUpdateInfo::_internal_set_content(const std::string& value) {
  
  _impl_.content_.Set(value, GetArenaForAllocation());
}
inline std::string* ConfigUpdateInfo::_internal_mutable_content() {
  
  return _impl_.content_.Mutable(GetArenaForAllocation());
}
inline std::string* ConfigUpdateInfo::release_content() {
  // @@protoc_insertion_point(field_release:configserver.proto.ConfigUpdateInfo.content)
  return _impl_.content_.Release();
}
inline void ConfigUpdateInfo::set_allocated_content(std::string* content) {
  if (content != nullptr) {
    
  } else {
    
  }
  _impl_.content_.SetAllocated(content, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.content_.IsDefault()) {
    _impl_.content_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:configserver.proto.ConfigUpdateInfo.content)
}

// -------------------------------------------------------------------

// AgentGetConfigListResponse

// string response_id = 1;
inline void AgentGetConfigListResponse::clear_response_id() {
  _impl_.response_id_.ClearToEmpty();
}
inline const std::string& AgentGetConfigListResponse::response_id() const {
  // @@protoc_insertion_point(field_get:configserver.proto.AgentGetConfigListResponse.response_id)
  return _internal_response_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void AgentGetConfigListResponse::set_response_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.response_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:configserver.proto.AgentGetConfigListResponse.response_id)
}
inline std::string* AgentGetConfigListResponse::mutable_response_id() {
  std::string* _s = _internal_mutable_response_id();
  // @@protoc_insertion_point(field_mutable:configserver.proto.AgentGetConfigListResponse.response_id)
  return _s;
}
inline const std::string& AgentGetConfigListResponse::_internal_response_id() const {
  return _impl_.response_id_.Get();
}
inline void AgentGetConfigListResponse::_internal_set_response_id(const std::string& value) {
  
  _impl_.response_id_.Set(value, GetArenaForAllocation());
}
inline std::string* AgentGetConfigListResponse::_internal_mutable_response_id() {
  
  return _impl_.response_id_.Mutable(GetArenaForAllocation());
}
inline std::string* AgentGetConfigListResponse::release_response_id() {
  // @@protoc_insertion_point(field_release:configserver.proto.AgentGetConfigListResponse.response_id)
  return _impl_.response_id_.Release();
}
inline void AgentGetConfigListResponse::set_allocated_response_id(std::string* response_id) {
  if (response_id != nullptr) {
    
  } else {
    
  }
  _impl_.response_id_.SetAllocated(response_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.response_id_.IsDefault()) {
    _impl_.response_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:configserver.proto.AgentGetConfigListResponse.response_id)
}

// string code = 2;
inline void AgentGetConfigListResponse::clear_code() {
  _impl_.code_.ClearToEmpty();
}
inline const std::string& AgentGetConfigListResponse::code() const {
  // @@protoc_insertion_point(field_get:configserver.proto.AgentGetConfigListResponse.code)
  return _internal_code();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void AgentGetConfigListResponse::set_code(ArgT0&& arg0, ArgT... args) {
 
 _impl_.code_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:configserver.proto.AgentGetConfigListResponse.code)
}
inline std::string* AgentGetConfigListResponse::mutable_code() {
  std::string* _s = _internal_mutable_code();
  // @@protoc_insertion_point(field_mutable:configserver.proto.AgentGetConfigListResponse.code)
  return _s;
}
inline const std::string& AgentGetConfigListResponse::_internal_code() const {
  return _impl_.code_.Get();
}
inline void AgentGetConfigListResponse::_internal_set_code(const std::string& value) {
  
  _impl_.code_.Set(value, GetArenaForAllocation());
}
inline std::string* AgentGetConfigListResponse::_internal_mutable_code() {
  
  return _impl_.code_.Mutable(GetArenaForAllocation());
}
inline std::string* AgentGetConfigListResponse::release_code() {
  // @@protoc_insertion_point(field_release:configserver.proto.AgentGetConfigListResponse.code)
  return _impl_.code_.Release();
}
inline void AgentGetConfigListResponse::set_allocated_code(std::string* code) {
  if (code != nullptr) {
    
  } else {
    
  }
  _impl_.code_.SetAllocated(code, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.code_.IsDefault()) {
    _impl_.code_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:configserver.proto.AgentGetConfigListResponse.code)
}

// string message = 3;
inline void AgentGetConfigListResponse::clear_message() {
  _impl_.message_.ClearToEmpty();
}
inline const std::string& AgentGetConfigListResponse::message() const {
  // @@protoc_insertion_point(field_get:configserver.proto.AgentGetConfigListResponse.message)
  return _internal_message();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void AgentGetConfigListResponse::set_message(ArgT0&& arg0, ArgT... args) {
 
 _impl_.message_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:configserver.proto.AgentGetConfigListResponse.message)
}
inline std::string* AgentGetConfigListResponse::mutable_message() {
  std::string* _s = _internal_mutable_message();
  // @@protoc_insertion_point(field_mutable:configserver.proto.AgentGetConfigListResponse.message)
  return _s;
}
inline const std::string& AgentGetConfigListResponse::_internal_message() const {
  return _impl_.message_.Get();
}
inline void AgentGetConfigListResponse::_internal_set_message(const std::string& value) {
  
  _impl_.message_.Set(value, GetArenaForAllocation());
}
inline std::string* AgentGetConfigListResponse::_internal_mutable_message() {
  
  return _impl_.message_.Mutable(GetArenaForAllocation());
}
inline std::string* AgentGetConfigListResponse::release_message() {
  // @@protoc_insertion_point(field_release:configserver.proto.AgentGetConfigListResponse.message)
  return _impl_.message_.Release();
}
inline void AgentGetConfigListResponse::set_allocated_message(std::string* message) {
  if (message != nullptr) {
    
  } else {
    
  }
  _impl_.message_.SetAllocated(message, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.message_.IsDefault()) {
    _impl_.message_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:configserver.proto.AgentGetConfigListResponse.message)
}

// repeated .configserver.proto.ConfigUpdateInfo config_update_infos = 4;
inline int AgentGetConfigListResponse::_internal_config_update_infos_size() const {
  return _impl_.config_update_infos_.size();
}
inline int AgentGetConfigListResponse::config_update_infos_size() const {
  return _internal_config_update_infos_size();
}
inline void AgentGetConfigListResponse::clear_config_update_infos() {
  _impl_.config_update_infos_.Clear();
}
inline ::configserver::proto::ConfigUpdateInfo* AgentGetConfigListResponse::mutable_config_update_infos(int index) {
  // @@protoc_insertion_point(field_mutable:configserver.proto.AgentGetConfigListResponse.config_update_infos)
  return _impl_.config_update_infos_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::configserver::proto::ConfigUpdateInfo >*
AgentGetConfigListResponse::mutable_config_update_infos() {
  // @@protoc_insertion_point(field_mutable_list:configserver.proto.AgentGetConfigListResponse.config_update_infos)
  return &_impl_.config_update_infos_;
}
inline const ::configserver::proto::ConfigUpdateInfo& AgentGetConfigListResponse::_internal_config_update_infos(int index) const {
  return _impl_.config_update_infos_.Get(index);
}
inline const ::configserver::proto::ConfigUpdateInfo& AgentGetConfigListResponse::config_update_infos(int index) const {
  // @@protoc_insertion_point(field_get:configserver.proto.AgentGetConfigListResponse.config_update_infos)
  return _internal_config_update_infos(index);
}
inline ::configserver::proto::ConfigUpdateInfo* AgentGetConfigListResponse::_internal_add_config_update_infos() {
  return _impl_.config_update_infos_.Add();
}
inline ::configserver::proto::ConfigUpdateInfo* AgentGetConfigListResponse::add_config_update_infos() {
  ::configserver::proto::ConfigUpdateInfo* _add = _internal_add_config_update_infos();
  // @@protoc_insertion_point(field_add:configserver.proto.AgentGetConfigListResponse.config_update_infos)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::configserver::proto::ConfigUpdateInfo >&
AgentGetConfigListResponse::config_update_infos() const {
  // @@protoc_insertion_point(field_list:configserver.proto.AgentGetConfigListResponse.config_update_infos)
  return _impl_.config_update_infos_;
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace proto
}  // namespace configserver

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::configserver::proto::ConfigUpdateInfo_UpdateStatus> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::configserver::proto::ConfigUpdateInfo_UpdateStatus>() {
  return ::configserver::proto::ConfigUpdateInfo_UpdateStatus_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_agent_2eproto
