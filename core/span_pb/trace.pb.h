// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: trace.proto

#ifndef PROTOBUF_INCLUDED_trace_2eproto
#define PROTOBUF_INCLUDED_trace_2eproto

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3006001
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3006001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#define PROTOBUF_INTERNAL_EXPORT_protobuf_trace_2eproto 

namespace protobuf_trace_2eproto {
// Internal implementation detail -- do not use these members.
struct TableStruct {
  static const ::google::protobuf::internal::ParseTableField entries[];
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[];
  static const ::google::protobuf::internal::ParseTable schema[13];
  static const ::google::protobuf::internal::FieldMetadata field_metadata[];
  static const ::google::protobuf::internal::SerializationTable serialization_table[];
  static const ::google::protobuf::uint32 offsets[];
};
void AddDescriptors();
}  // namespace protobuf_trace_2eproto
class AnyValue;
class AnyValueDefaultTypeInternal;
extern AnyValueDefaultTypeInternal _AnyValue_default_instance_;
class ArrayValue;
class ArrayValueDefaultTypeInternal;
extern ArrayValueDefaultTypeInternal _ArrayValue_default_instance_;
class InstrumentationScope;
class InstrumentationScopeDefaultTypeInternal;
extern InstrumentationScopeDefaultTypeInternal _InstrumentationScope_default_instance_;
class KeyValue;
class KeyValueDefaultTypeInternal;
extern KeyValueDefaultTypeInternal _KeyValue_default_instance_;
class KeyValueList;
class KeyValueListDefaultTypeInternal;
extern KeyValueListDefaultTypeInternal _KeyValueList_default_instance_;
class Resource;
class ResourceDefaultTypeInternal;
extern ResourceDefaultTypeInternal _Resource_default_instance_;
class ResourceSpans;
class ResourceSpansDefaultTypeInternal;
extern ResourceSpansDefaultTypeInternal _ResourceSpans_default_instance_;
class ScopeSpans;
class ScopeSpansDefaultTypeInternal;
extern ScopeSpansDefaultTypeInternal _ScopeSpans_default_instance_;
class Span;
class SpanDefaultTypeInternal;
extern SpanDefaultTypeInternal _Span_default_instance_;
class Span_Event;
class Span_EventDefaultTypeInternal;
extern Span_EventDefaultTypeInternal _Span_Event_default_instance_;
class Span_Link;
class Span_LinkDefaultTypeInternal;
extern Span_LinkDefaultTypeInternal _Span_Link_default_instance_;
class Status;
class StatusDefaultTypeInternal;
extern StatusDefaultTypeInternal _Status_default_instance_;
class TracesData;
class TracesDataDefaultTypeInternal;
extern TracesDataDefaultTypeInternal _TracesData_default_instance_;
namespace google {
namespace protobuf {
template<> ::AnyValue* Arena::CreateMaybeMessage<::AnyValue>(Arena*);
template<> ::ArrayValue* Arena::CreateMaybeMessage<::ArrayValue>(Arena*);
template<> ::InstrumentationScope* Arena::CreateMaybeMessage<::InstrumentationScope>(Arena*);
template<> ::KeyValue* Arena::CreateMaybeMessage<::KeyValue>(Arena*);
template<> ::KeyValueList* Arena::CreateMaybeMessage<::KeyValueList>(Arena*);
template<> ::Resource* Arena::CreateMaybeMessage<::Resource>(Arena*);
template<> ::ResourceSpans* Arena::CreateMaybeMessage<::ResourceSpans>(Arena*);
template<> ::ScopeSpans* Arena::CreateMaybeMessage<::ScopeSpans>(Arena*);
template<> ::Span* Arena::CreateMaybeMessage<::Span>(Arena*);
template<> ::Span_Event* Arena::CreateMaybeMessage<::Span_Event>(Arena*);
template<> ::Span_Link* Arena::CreateMaybeMessage<::Span_Link>(Arena*);
template<> ::Status* Arena::CreateMaybeMessage<::Status>(Arena*);
template<> ::TracesData* Arena::CreateMaybeMessage<::TracesData>(Arena*);
}  // namespace protobuf
}  // namespace google

enum Span_SpanKind {
  Span_SpanKind_SPAN_KIND_UNSPECIFIED = 0,
  Span_SpanKind_SPAN_KIND_INTERNAL = 1,
  Span_SpanKind_SPAN_KIND_SERVER = 2,
  Span_SpanKind_SPAN_KIND_CLIENT = 3,
  Span_SpanKind_SPAN_KIND_PRODUCER = 4,
  Span_SpanKind_SPAN_KIND_CONSUMER = 5,
  Span_SpanKind_Span_SpanKind_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  Span_SpanKind_Span_SpanKind_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool Span_SpanKind_IsValid(int value);
const Span_SpanKind Span_SpanKind_SpanKind_MIN = Span_SpanKind_SPAN_KIND_UNSPECIFIED;
const Span_SpanKind Span_SpanKind_SpanKind_MAX = Span_SpanKind_SPAN_KIND_CONSUMER;
const int Span_SpanKind_SpanKind_ARRAYSIZE = Span_SpanKind_SpanKind_MAX + 1;

const ::google::protobuf::EnumDescriptor* Span_SpanKind_descriptor();
inline const ::std::string& Span_SpanKind_Name(Span_SpanKind value) {
  return ::google::protobuf::internal::NameOfEnum(
    Span_SpanKind_descriptor(), value);
}
inline bool Span_SpanKind_Parse(
    const ::std::string& name, Span_SpanKind* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Span_SpanKind>(
    Span_SpanKind_descriptor(), name, value);
}
enum Status_StatusCode {
  Status_StatusCode_STATUS_CODE_UNSET = 0,
  Status_StatusCode_STATUS_CODE_OK = 1,
  Status_StatusCode_STATUS_CODE_ERROR = 2,
  Status_StatusCode_Status_StatusCode_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  Status_StatusCode_Status_StatusCode_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool Status_StatusCode_IsValid(int value);
const Status_StatusCode Status_StatusCode_StatusCode_MIN = Status_StatusCode_STATUS_CODE_UNSET;
const Status_StatusCode Status_StatusCode_StatusCode_MAX = Status_StatusCode_STATUS_CODE_ERROR;
const int Status_StatusCode_StatusCode_ARRAYSIZE = Status_StatusCode_StatusCode_MAX + 1;

const ::google::protobuf::EnumDescriptor* Status_StatusCode_descriptor();
inline const ::std::string& Status_StatusCode_Name(Status_StatusCode value) {
  return ::google::protobuf::internal::NameOfEnum(
    Status_StatusCode_descriptor(), value);
}
inline bool Status_StatusCode_Parse(
    const ::std::string& name, Status_StatusCode* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Status_StatusCode>(
    Status_StatusCode_descriptor(), name, value);
}
enum SpanFlags {
  SPAN_FLAGS_DO_NOT_USE = 0,
  SPAN_FLAGS_TRACE_FLAGS_MASK = 255,
  SPAN_FLAGS_CONTEXT_HAS_IS_REMOTE_MASK = 256,
  SPAN_FLAGS_CONTEXT_IS_REMOTE_MASK = 512,
  SpanFlags_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  SpanFlags_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool SpanFlags_IsValid(int value);
const SpanFlags SpanFlags_MIN = SPAN_FLAGS_DO_NOT_USE;
const SpanFlags SpanFlags_MAX = SPAN_FLAGS_CONTEXT_IS_REMOTE_MASK;
const int SpanFlags_ARRAYSIZE = SpanFlags_MAX + 1;

const ::google::protobuf::EnumDescriptor* SpanFlags_descriptor();
inline const ::std::string& SpanFlags_Name(SpanFlags value) {
  return ::google::protobuf::internal::NameOfEnum(
    SpanFlags_descriptor(), value);
}
inline bool SpanFlags_Parse(
    const ::std::string& name, SpanFlags* value) {
  return ::google::protobuf::internal::ParseNamedEnum<SpanFlags>(
    SpanFlags_descriptor(), name, value);
}
// ===================================================================

class AnyValue : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:AnyValue) */ {
 public:
  AnyValue();
  virtual ~AnyValue();

  AnyValue(const AnyValue& from);

  inline AnyValue& operator=(const AnyValue& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  AnyValue(AnyValue&& from) noexcept
    : AnyValue() {
    *this = ::std::move(from);
  }

  inline AnyValue& operator=(AnyValue&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const AnyValue& default_instance();

  enum ValueCase {
    kStringValue = 1,
    kBoolValue = 2,
    kIntValue = 3,
    kDoubleValue = 4,
    kArrayValue = 5,
    kKvlistValue = 6,
    kBytesValue = 7,
    VALUE_NOT_SET = 0,
  };

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const AnyValue* internal_default_instance() {
    return reinterpret_cast<const AnyValue*>(
               &_AnyValue_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  void Swap(AnyValue* other);
  friend void swap(AnyValue& a, AnyValue& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline AnyValue* New() const final {
    return CreateMaybeMessage<AnyValue>(NULL);
  }

  AnyValue* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<AnyValue>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const AnyValue& from);
  void MergeFrom(const AnyValue& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AnyValue* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string string_value = 1;
  private:
  bool has_string_value() const;
  public:
  void clear_string_value();
  static const int kStringValueFieldNumber = 1;
  const ::std::string& string_value() const;
  void set_string_value(const ::std::string& value);
  #if LANG_CXX11
  void set_string_value(::std::string&& value);
  #endif
  void set_string_value(const char* value);
  void set_string_value(const char* value, size_t size);
  ::std::string* mutable_string_value();
  ::std::string* release_string_value();
  void set_allocated_string_value(::std::string* string_value);

  // bool bool_value = 2;
  private:
  bool has_bool_value() const;
  public:
  void clear_bool_value();
  static const int kBoolValueFieldNumber = 2;
  bool bool_value() const;
  void set_bool_value(bool value);

  // int64 int_value = 3;
  private:
  bool has_int_value() const;
  public:
  void clear_int_value();
  static const int kIntValueFieldNumber = 3;
  ::google::protobuf::int64 int_value() const;
  void set_int_value(::google::protobuf::int64 value);

  // double double_value = 4;
  private:
  bool has_double_value() const;
  public:
  void clear_double_value();
  static const int kDoubleValueFieldNumber = 4;
  double double_value() const;
  void set_double_value(double value);

  // .ArrayValue array_value = 5;
  bool has_array_value() const;
  void clear_array_value();
  static const int kArrayValueFieldNumber = 5;
  private:
  const ::ArrayValue& _internal_array_value() const;
  public:
  const ::ArrayValue& array_value() const;
  ::ArrayValue* release_array_value();
  ::ArrayValue* mutable_array_value();
  void set_allocated_array_value(::ArrayValue* array_value);

  // .KeyValueList kvlist_value = 6;
  bool has_kvlist_value() const;
  void clear_kvlist_value();
  static const int kKvlistValueFieldNumber = 6;
  private:
  const ::KeyValueList& _internal_kvlist_value() const;
  public:
  const ::KeyValueList& kvlist_value() const;
  ::KeyValueList* release_kvlist_value();
  ::KeyValueList* mutable_kvlist_value();
  void set_allocated_kvlist_value(::KeyValueList* kvlist_value);

  // bytes bytes_value = 7;
  private:
  bool has_bytes_value() const;
  public:
  void clear_bytes_value();
  static const int kBytesValueFieldNumber = 7;
  const ::std::string& bytes_value() const;
  void set_bytes_value(const ::std::string& value);
  #if LANG_CXX11
  void set_bytes_value(::std::string&& value);
  #endif
  void set_bytes_value(const char* value);
  void set_bytes_value(const void* value, size_t size);
  ::std::string* mutable_bytes_value();
  ::std::string* release_bytes_value();
  void set_allocated_bytes_value(::std::string* bytes_value);

  void clear_value();
  ValueCase value_case() const;
  // @@protoc_insertion_point(class_scope:AnyValue)
 private:
  void set_has_string_value();
  void set_has_bool_value();
  void set_has_int_value();
  void set_has_double_value();
  void set_has_array_value();
  void set_has_kvlist_value();
  void set_has_bytes_value();

  inline bool has_value() const;
  inline void clear_has_value();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  union ValueUnion {
    ValueUnion() {}
    ::google::protobuf::internal::ArenaStringPtr string_value_;
    bool bool_value_;
    ::google::protobuf::int64 int_value_;
    double double_value_;
    ::ArrayValue* array_value_;
    ::KeyValueList* kvlist_value_;
    ::google::protobuf::internal::ArenaStringPtr bytes_value_;
  } value_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::uint32 _oneof_case_[1];

  friend struct ::protobuf_trace_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ArrayValue : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ArrayValue) */ {
 public:
  ArrayValue();
  virtual ~ArrayValue();

  ArrayValue(const ArrayValue& from);

  inline ArrayValue& operator=(const ArrayValue& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ArrayValue(ArrayValue&& from) noexcept
    : ArrayValue() {
    *this = ::std::move(from);
  }

  inline ArrayValue& operator=(ArrayValue&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const ArrayValue& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ArrayValue* internal_default_instance() {
    return reinterpret_cast<const ArrayValue*>(
               &_ArrayValue_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  void Swap(ArrayValue* other);
  friend void swap(ArrayValue& a, ArrayValue& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ArrayValue* New() const final {
    return CreateMaybeMessage<ArrayValue>(NULL);
  }

  ArrayValue* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ArrayValue>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ArrayValue& from);
  void MergeFrom(const ArrayValue& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ArrayValue* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .AnyValue values = 1;
  int values_size() const;
  void clear_values();
  static const int kValuesFieldNumber = 1;
  ::AnyValue* mutable_values(int index);
  ::google::protobuf::RepeatedPtrField< ::AnyValue >*
      mutable_values();
  const ::AnyValue& values(int index) const;
  ::AnyValue* add_values();
  const ::google::protobuf::RepeatedPtrField< ::AnyValue >&
      values() const;

  // @@protoc_insertion_point(class_scope:ArrayValue)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::AnyValue > values_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_trace_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class KeyValueList : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:KeyValueList) */ {
 public:
  KeyValueList();
  virtual ~KeyValueList();

  KeyValueList(const KeyValueList& from);

  inline KeyValueList& operator=(const KeyValueList& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  KeyValueList(KeyValueList&& from) noexcept
    : KeyValueList() {
    *this = ::std::move(from);
  }

  inline KeyValueList& operator=(KeyValueList&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const KeyValueList& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const KeyValueList* internal_default_instance() {
    return reinterpret_cast<const KeyValueList*>(
               &_KeyValueList_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  void Swap(KeyValueList* other);
  friend void swap(KeyValueList& a, KeyValueList& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline KeyValueList* New() const final {
    return CreateMaybeMessage<KeyValueList>(NULL);
  }

  KeyValueList* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<KeyValueList>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const KeyValueList& from);
  void MergeFrom(const KeyValueList& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(KeyValueList* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .KeyValue values = 1;
  int values_size() const;
  void clear_values();
  static const int kValuesFieldNumber = 1;
  ::KeyValue* mutable_values(int index);
  ::google::protobuf::RepeatedPtrField< ::KeyValue >*
      mutable_values();
  const ::KeyValue& values(int index) const;
  ::KeyValue* add_values();
  const ::google::protobuf::RepeatedPtrField< ::KeyValue >&
      values() const;

  // @@protoc_insertion_point(class_scope:KeyValueList)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::KeyValue > values_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_trace_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class KeyValue : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:KeyValue) */ {
 public:
  KeyValue();
  virtual ~KeyValue();

  KeyValue(const KeyValue& from);

  inline KeyValue& operator=(const KeyValue& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  KeyValue(KeyValue&& from) noexcept
    : KeyValue() {
    *this = ::std::move(from);
  }

  inline KeyValue& operator=(KeyValue&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const KeyValue& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const KeyValue* internal_default_instance() {
    return reinterpret_cast<const KeyValue*>(
               &_KeyValue_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  void Swap(KeyValue* other);
  friend void swap(KeyValue& a, KeyValue& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline KeyValue* New() const final {
    return CreateMaybeMessage<KeyValue>(NULL);
  }

  KeyValue* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<KeyValue>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const KeyValue& from);
  void MergeFrom(const KeyValue& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(KeyValue* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string key = 1;
  void clear_key();
  static const int kKeyFieldNumber = 1;
  const ::std::string& key() const;
  void set_key(const ::std::string& value);
  #if LANG_CXX11
  void set_key(::std::string&& value);
  #endif
  void set_key(const char* value);
  void set_key(const char* value, size_t size);
  ::std::string* mutable_key();
  ::std::string* release_key();
  void set_allocated_key(::std::string* key);

  // .AnyValue value = 2;
  bool has_value() const;
  void clear_value();
  static const int kValueFieldNumber = 2;
  private:
  const ::AnyValue& _internal_value() const;
  public:
  const ::AnyValue& value() const;
  ::AnyValue* release_value();
  ::AnyValue* mutable_value();
  void set_allocated_value(::AnyValue* value);

  // @@protoc_insertion_point(class_scope:KeyValue)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr key_;
  ::AnyValue* value_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_trace_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class InstrumentationScope : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:InstrumentationScope) */ {
 public:
  InstrumentationScope();
  virtual ~InstrumentationScope();

  InstrumentationScope(const InstrumentationScope& from);

  inline InstrumentationScope& operator=(const InstrumentationScope& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  InstrumentationScope(InstrumentationScope&& from) noexcept
    : InstrumentationScope() {
    *this = ::std::move(from);
  }

  inline InstrumentationScope& operator=(InstrumentationScope&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const InstrumentationScope& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const InstrumentationScope* internal_default_instance() {
    return reinterpret_cast<const InstrumentationScope*>(
               &_InstrumentationScope_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  void Swap(InstrumentationScope* other);
  friend void swap(InstrumentationScope& a, InstrumentationScope& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline InstrumentationScope* New() const final {
    return CreateMaybeMessage<InstrumentationScope>(NULL);
  }

  InstrumentationScope* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<InstrumentationScope>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const InstrumentationScope& from);
  void MergeFrom(const InstrumentationScope& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(InstrumentationScope* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .KeyValue attributes = 3;
  int attributes_size() const;
  void clear_attributes();
  static const int kAttributesFieldNumber = 3;
  ::KeyValue* mutable_attributes(int index);
  ::google::protobuf::RepeatedPtrField< ::KeyValue >*
      mutable_attributes();
  const ::KeyValue& attributes(int index) const;
  ::KeyValue* add_attributes();
  const ::google::protobuf::RepeatedPtrField< ::KeyValue >&
      attributes() const;

  // string name = 1;
  void clear_name();
  static const int kNameFieldNumber = 1;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  #if LANG_CXX11
  void set_name(::std::string&& value);
  #endif
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // string version = 2;
  void clear_version();
  static const int kVersionFieldNumber = 2;
  const ::std::string& version() const;
  void set_version(const ::std::string& value);
  #if LANG_CXX11
  void set_version(::std::string&& value);
  #endif
  void set_version(const char* value);
  void set_version(const char* value, size_t size);
  ::std::string* mutable_version();
  ::std::string* release_version();
  void set_allocated_version(::std::string* version);

  // uint32 dropped_attributes_count = 4;
  void clear_dropped_attributes_count();
  static const int kDroppedAttributesCountFieldNumber = 4;
  ::google::protobuf::uint32 dropped_attributes_count() const;
  void set_dropped_attributes_count(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:InstrumentationScope)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::KeyValue > attributes_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  ::google::protobuf::internal::ArenaStringPtr version_;
  ::google::protobuf::uint32 dropped_attributes_count_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_trace_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Resource : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Resource) */ {
 public:
  Resource();
  virtual ~Resource();

  Resource(const Resource& from);

  inline Resource& operator=(const Resource& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Resource(Resource&& from) noexcept
    : Resource() {
    *this = ::std::move(from);
  }

  inline Resource& operator=(Resource&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Resource& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Resource* internal_default_instance() {
    return reinterpret_cast<const Resource*>(
               &_Resource_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  void Swap(Resource* other);
  friend void swap(Resource& a, Resource& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Resource* New() const final {
    return CreateMaybeMessage<Resource>(NULL);
  }

  Resource* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Resource>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Resource& from);
  void MergeFrom(const Resource& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Resource* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .KeyValue attributes = 1;
  int attributes_size() const;
  void clear_attributes();
  static const int kAttributesFieldNumber = 1;
  ::KeyValue* mutable_attributes(int index);
  ::google::protobuf::RepeatedPtrField< ::KeyValue >*
      mutable_attributes();
  const ::KeyValue& attributes(int index) const;
  ::KeyValue* add_attributes();
  const ::google::protobuf::RepeatedPtrField< ::KeyValue >&
      attributes() const;

  // uint32 dropped_attributes_count = 2;
  void clear_dropped_attributes_count();
  static const int kDroppedAttributesCountFieldNumber = 2;
  ::google::protobuf::uint32 dropped_attributes_count() const;
  void set_dropped_attributes_count(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:Resource)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::KeyValue > attributes_;
  ::google::protobuf::uint32 dropped_attributes_count_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_trace_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class TracesData : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:TracesData) */ {
 public:
  TracesData();
  virtual ~TracesData();

  TracesData(const TracesData& from);

  inline TracesData& operator=(const TracesData& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  TracesData(TracesData&& from) noexcept
    : TracesData() {
    *this = ::std::move(from);
  }

  inline TracesData& operator=(TracesData&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const TracesData& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const TracesData* internal_default_instance() {
    return reinterpret_cast<const TracesData*>(
               &_TracesData_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  void Swap(TracesData* other);
  friend void swap(TracesData& a, TracesData& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline TracesData* New() const final {
    return CreateMaybeMessage<TracesData>(NULL);
  }

  TracesData* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<TracesData>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const TracesData& from);
  void MergeFrom(const TracesData& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TracesData* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .ResourceSpans resource_spans = 1;
  int resource_spans_size() const;
  void clear_resource_spans();
  static const int kResourceSpansFieldNumber = 1;
  ::ResourceSpans* mutable_resource_spans(int index);
  ::google::protobuf::RepeatedPtrField< ::ResourceSpans >*
      mutable_resource_spans();
  const ::ResourceSpans& resource_spans(int index) const;
  ::ResourceSpans* add_resource_spans();
  const ::google::protobuf::RepeatedPtrField< ::ResourceSpans >&
      resource_spans() const;

  // @@protoc_insertion_point(class_scope:TracesData)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::ResourceSpans > resource_spans_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_trace_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ResourceSpans : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ResourceSpans) */ {
 public:
  ResourceSpans();
  virtual ~ResourceSpans();

  ResourceSpans(const ResourceSpans& from);

  inline ResourceSpans& operator=(const ResourceSpans& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ResourceSpans(ResourceSpans&& from) noexcept
    : ResourceSpans() {
    *this = ::std::move(from);
  }

  inline ResourceSpans& operator=(ResourceSpans&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const ResourceSpans& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ResourceSpans* internal_default_instance() {
    return reinterpret_cast<const ResourceSpans*>(
               &_ResourceSpans_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  void Swap(ResourceSpans* other);
  friend void swap(ResourceSpans& a, ResourceSpans& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ResourceSpans* New() const final {
    return CreateMaybeMessage<ResourceSpans>(NULL);
  }

  ResourceSpans* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ResourceSpans>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ResourceSpans& from);
  void MergeFrom(const ResourceSpans& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ResourceSpans* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .ScopeSpans scope_spans = 2;
  int scope_spans_size() const;
  void clear_scope_spans();
  static const int kScopeSpansFieldNumber = 2;
  ::ScopeSpans* mutable_scope_spans(int index);
  ::google::protobuf::RepeatedPtrField< ::ScopeSpans >*
      mutable_scope_spans();
  const ::ScopeSpans& scope_spans(int index) const;
  ::ScopeSpans* add_scope_spans();
  const ::google::protobuf::RepeatedPtrField< ::ScopeSpans >&
      scope_spans() const;

  // string schema_url = 3;
  void clear_schema_url();
  static const int kSchemaUrlFieldNumber = 3;
  const ::std::string& schema_url() const;
  void set_schema_url(const ::std::string& value);
  #if LANG_CXX11
  void set_schema_url(::std::string&& value);
  #endif
  void set_schema_url(const char* value);
  void set_schema_url(const char* value, size_t size);
  ::std::string* mutable_schema_url();
  ::std::string* release_schema_url();
  void set_allocated_schema_url(::std::string* schema_url);

  // .Resource resource = 1;
  bool has_resource() const;
  void clear_resource();
  static const int kResourceFieldNumber = 1;
  private:
  const ::Resource& _internal_resource() const;
  public:
  const ::Resource& resource() const;
  ::Resource* release_resource();
  ::Resource* mutable_resource();
  void set_allocated_resource(::Resource* resource);

  // @@protoc_insertion_point(class_scope:ResourceSpans)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::ScopeSpans > scope_spans_;
  ::google::protobuf::internal::ArenaStringPtr schema_url_;
  ::Resource* resource_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_trace_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ScopeSpans : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ScopeSpans) */ {
 public:
  ScopeSpans();
  virtual ~ScopeSpans();

  ScopeSpans(const ScopeSpans& from);

  inline ScopeSpans& operator=(const ScopeSpans& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ScopeSpans(ScopeSpans&& from) noexcept
    : ScopeSpans() {
    *this = ::std::move(from);
  }

  inline ScopeSpans& operator=(ScopeSpans&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const ScopeSpans& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ScopeSpans* internal_default_instance() {
    return reinterpret_cast<const ScopeSpans*>(
               &_ScopeSpans_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  void Swap(ScopeSpans* other);
  friend void swap(ScopeSpans& a, ScopeSpans& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ScopeSpans* New() const final {
    return CreateMaybeMessage<ScopeSpans>(NULL);
  }

  ScopeSpans* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ScopeSpans>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ScopeSpans& from);
  void MergeFrom(const ScopeSpans& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ScopeSpans* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .Span spans = 2;
  int spans_size() const;
  void clear_spans();
  static const int kSpansFieldNumber = 2;
  ::Span* mutable_spans(int index);
  ::google::protobuf::RepeatedPtrField< ::Span >*
      mutable_spans();
  const ::Span& spans(int index) const;
  ::Span* add_spans();
  const ::google::protobuf::RepeatedPtrField< ::Span >&
      spans() const;

  // string schema_url = 3;
  void clear_schema_url();
  static const int kSchemaUrlFieldNumber = 3;
  const ::std::string& schema_url() const;
  void set_schema_url(const ::std::string& value);
  #if LANG_CXX11
  void set_schema_url(::std::string&& value);
  #endif
  void set_schema_url(const char* value);
  void set_schema_url(const char* value, size_t size);
  ::std::string* mutable_schema_url();
  ::std::string* release_schema_url();
  void set_allocated_schema_url(::std::string* schema_url);

  // .InstrumentationScope scope = 1;
  bool has_scope() const;
  void clear_scope();
  static const int kScopeFieldNumber = 1;
  private:
  const ::InstrumentationScope& _internal_scope() const;
  public:
  const ::InstrumentationScope& scope() const;
  ::InstrumentationScope* release_scope();
  ::InstrumentationScope* mutable_scope();
  void set_allocated_scope(::InstrumentationScope* scope);

  // @@protoc_insertion_point(class_scope:ScopeSpans)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::Span > spans_;
  ::google::protobuf::internal::ArenaStringPtr schema_url_;
  ::InstrumentationScope* scope_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_trace_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Span_Event : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Span.Event) */ {
 public:
  Span_Event();
  virtual ~Span_Event();

  Span_Event(const Span_Event& from);

  inline Span_Event& operator=(const Span_Event& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Span_Event(Span_Event&& from) noexcept
    : Span_Event() {
    *this = ::std::move(from);
  }

  inline Span_Event& operator=(Span_Event&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Span_Event& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Span_Event* internal_default_instance() {
    return reinterpret_cast<const Span_Event*>(
               &_Span_Event_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  void Swap(Span_Event* other);
  friend void swap(Span_Event& a, Span_Event& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Span_Event* New() const final {
    return CreateMaybeMessage<Span_Event>(NULL);
  }

  Span_Event* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Span_Event>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Span_Event& from);
  void MergeFrom(const Span_Event& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Span_Event* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .KeyValue attributes = 3;
  int attributes_size() const;
  void clear_attributes();
  static const int kAttributesFieldNumber = 3;
  ::KeyValue* mutable_attributes(int index);
  ::google::protobuf::RepeatedPtrField< ::KeyValue >*
      mutable_attributes();
  const ::KeyValue& attributes(int index) const;
  ::KeyValue* add_attributes();
  const ::google::protobuf::RepeatedPtrField< ::KeyValue >&
      attributes() const;

  // string name = 2;
  void clear_name();
  static const int kNameFieldNumber = 2;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  #if LANG_CXX11
  void set_name(::std::string&& value);
  #endif
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // fixed64 time_unix_nano = 1;
  void clear_time_unix_nano();
  static const int kTimeUnixNanoFieldNumber = 1;
  ::google::protobuf::uint64 time_unix_nano() const;
  void set_time_unix_nano(::google::protobuf::uint64 value);

  // uint32 dropped_attributes_count = 4;
  void clear_dropped_attributes_count();
  static const int kDroppedAttributesCountFieldNumber = 4;
  ::google::protobuf::uint32 dropped_attributes_count() const;
  void set_dropped_attributes_count(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:Span.Event)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::KeyValue > attributes_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  ::google::protobuf::uint64 time_unix_nano_;
  ::google::protobuf::uint32 dropped_attributes_count_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_trace_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Span_Link : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Span.Link) */ {
 public:
  Span_Link();
  virtual ~Span_Link();

  Span_Link(const Span_Link& from);

  inline Span_Link& operator=(const Span_Link& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Span_Link(Span_Link&& from) noexcept
    : Span_Link() {
    *this = ::std::move(from);
  }

  inline Span_Link& operator=(Span_Link&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Span_Link& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Span_Link* internal_default_instance() {
    return reinterpret_cast<const Span_Link*>(
               &_Span_Link_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  void Swap(Span_Link* other);
  friend void swap(Span_Link& a, Span_Link& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Span_Link* New() const final {
    return CreateMaybeMessage<Span_Link>(NULL);
  }

  Span_Link* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Span_Link>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Span_Link& from);
  void MergeFrom(const Span_Link& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Span_Link* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .KeyValue attributes = 4;
  int attributes_size() const;
  void clear_attributes();
  static const int kAttributesFieldNumber = 4;
  ::KeyValue* mutable_attributes(int index);
  ::google::protobuf::RepeatedPtrField< ::KeyValue >*
      mutable_attributes();
  const ::KeyValue& attributes(int index) const;
  ::KeyValue* add_attributes();
  const ::google::protobuf::RepeatedPtrField< ::KeyValue >&
      attributes() const;

  // bytes trace_id = 1;
  void clear_trace_id();
  static const int kTraceIdFieldNumber = 1;
  const ::std::string& trace_id() const;
  void set_trace_id(const ::std::string& value);
  #if LANG_CXX11
  void set_trace_id(::std::string&& value);
  #endif
  void set_trace_id(const char* value);
  void set_trace_id(const void* value, size_t size);
  ::std::string* mutable_trace_id();
  ::std::string* release_trace_id();
  void set_allocated_trace_id(::std::string* trace_id);

  // bytes span_id = 2;
  void clear_span_id();
  static const int kSpanIdFieldNumber = 2;
  const ::std::string& span_id() const;
  void set_span_id(const ::std::string& value);
  #if LANG_CXX11
  void set_span_id(::std::string&& value);
  #endif
  void set_span_id(const char* value);
  void set_span_id(const void* value, size_t size);
  ::std::string* mutable_span_id();
  ::std::string* release_span_id();
  void set_allocated_span_id(::std::string* span_id);

  // string trace_state = 3;
  void clear_trace_state();
  static const int kTraceStateFieldNumber = 3;
  const ::std::string& trace_state() const;
  void set_trace_state(const ::std::string& value);
  #if LANG_CXX11
  void set_trace_state(::std::string&& value);
  #endif
  void set_trace_state(const char* value);
  void set_trace_state(const char* value, size_t size);
  ::std::string* mutable_trace_state();
  ::std::string* release_trace_state();
  void set_allocated_trace_state(::std::string* trace_state);

  // uint32 dropped_attributes_count = 5;
  void clear_dropped_attributes_count();
  static const int kDroppedAttributesCountFieldNumber = 5;
  ::google::protobuf::uint32 dropped_attributes_count() const;
  void set_dropped_attributes_count(::google::protobuf::uint32 value);

  // fixed32 flags = 6;
  void clear_flags();
  static const int kFlagsFieldNumber = 6;
  ::google::protobuf::uint32 flags() const;
  void set_flags(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:Span.Link)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::KeyValue > attributes_;
  ::google::protobuf::internal::ArenaStringPtr trace_id_;
  ::google::protobuf::internal::ArenaStringPtr span_id_;
  ::google::protobuf::internal::ArenaStringPtr trace_state_;
  ::google::protobuf::uint32 dropped_attributes_count_;
  ::google::protobuf::uint32 flags_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_trace_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Span : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Span) */ {
 public:
  Span();
  virtual ~Span();

  Span(const Span& from);

  inline Span& operator=(const Span& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Span(Span&& from) noexcept
    : Span() {
    *this = ::std::move(from);
  }

  inline Span& operator=(Span&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Span& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Span* internal_default_instance() {
    return reinterpret_cast<const Span*>(
               &_Span_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  void Swap(Span* other);
  friend void swap(Span& a, Span& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Span* New() const final {
    return CreateMaybeMessage<Span>(NULL);
  }

  Span* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Span>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Span& from);
  void MergeFrom(const Span& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Span* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef Span_Event Event;
  typedef Span_Link Link;

  typedef Span_SpanKind SpanKind;
  static const SpanKind SPAN_KIND_UNSPECIFIED =
    Span_SpanKind_SPAN_KIND_UNSPECIFIED;
  static const SpanKind SPAN_KIND_INTERNAL =
    Span_SpanKind_SPAN_KIND_INTERNAL;
  static const SpanKind SPAN_KIND_SERVER =
    Span_SpanKind_SPAN_KIND_SERVER;
  static const SpanKind SPAN_KIND_CLIENT =
    Span_SpanKind_SPAN_KIND_CLIENT;
  static const SpanKind SPAN_KIND_PRODUCER =
    Span_SpanKind_SPAN_KIND_PRODUCER;
  static const SpanKind SPAN_KIND_CONSUMER =
    Span_SpanKind_SPAN_KIND_CONSUMER;
  static inline bool SpanKind_IsValid(int value) {
    return Span_SpanKind_IsValid(value);
  }
  static const SpanKind SpanKind_MIN =
    Span_SpanKind_SpanKind_MIN;
  static const SpanKind SpanKind_MAX =
    Span_SpanKind_SpanKind_MAX;
  static const int SpanKind_ARRAYSIZE =
    Span_SpanKind_SpanKind_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  SpanKind_descriptor() {
    return Span_SpanKind_descriptor();
  }
  static inline const ::std::string& SpanKind_Name(SpanKind value) {
    return Span_SpanKind_Name(value);
  }
  static inline bool SpanKind_Parse(const ::std::string& name,
      SpanKind* value) {
    return Span_SpanKind_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // repeated .KeyValue attributes = 9;
  int attributes_size() const;
  void clear_attributes();
  static const int kAttributesFieldNumber = 9;
  ::KeyValue* mutable_attributes(int index);
  ::google::protobuf::RepeatedPtrField< ::KeyValue >*
      mutable_attributes();
  const ::KeyValue& attributes(int index) const;
  ::KeyValue* add_attributes();
  const ::google::protobuf::RepeatedPtrField< ::KeyValue >&
      attributes() const;

  // repeated .Span.Event events = 11;
  int events_size() const;
  void clear_events();
  static const int kEventsFieldNumber = 11;
  ::Span_Event* mutable_events(int index);
  ::google::protobuf::RepeatedPtrField< ::Span_Event >*
      mutable_events();
  const ::Span_Event& events(int index) const;
  ::Span_Event* add_events();
  const ::google::protobuf::RepeatedPtrField< ::Span_Event >&
      events() const;

  // repeated .Span.Link links = 13;
  int links_size() const;
  void clear_links();
  static const int kLinksFieldNumber = 13;
  ::Span_Link* mutable_links(int index);
  ::google::protobuf::RepeatedPtrField< ::Span_Link >*
      mutable_links();
  const ::Span_Link& links(int index) const;
  ::Span_Link* add_links();
  const ::google::protobuf::RepeatedPtrField< ::Span_Link >&
      links() const;

  // bytes trace_id = 1;
  void clear_trace_id();
  static const int kTraceIdFieldNumber = 1;
  const ::std::string& trace_id() const;
  void set_trace_id(const ::std::string& value);
  #if LANG_CXX11
  void set_trace_id(::std::string&& value);
  #endif
  void set_trace_id(const char* value);
  void set_trace_id(const void* value, size_t size);
  ::std::string* mutable_trace_id();
  ::std::string* release_trace_id();
  void set_allocated_trace_id(::std::string* trace_id);

  // bytes span_id = 2;
  void clear_span_id();
  static const int kSpanIdFieldNumber = 2;
  const ::std::string& span_id() const;
  void set_span_id(const ::std::string& value);
  #if LANG_CXX11
  void set_span_id(::std::string&& value);
  #endif
  void set_span_id(const char* value);
  void set_span_id(const void* value, size_t size);
  ::std::string* mutable_span_id();
  ::std::string* release_span_id();
  void set_allocated_span_id(::std::string* span_id);

  // string trace_state = 3;
  void clear_trace_state();
  static const int kTraceStateFieldNumber = 3;
  const ::std::string& trace_state() const;
  void set_trace_state(const ::std::string& value);
  #if LANG_CXX11
  void set_trace_state(::std::string&& value);
  #endif
  void set_trace_state(const char* value);
  void set_trace_state(const char* value, size_t size);
  ::std::string* mutable_trace_state();
  ::std::string* release_trace_state();
  void set_allocated_trace_state(::std::string* trace_state);

  // bytes parent_span_id = 4;
  void clear_parent_span_id();
  static const int kParentSpanIdFieldNumber = 4;
  const ::std::string& parent_span_id() const;
  void set_parent_span_id(const ::std::string& value);
  #if LANG_CXX11
  void set_parent_span_id(::std::string&& value);
  #endif
  void set_parent_span_id(const char* value);
  void set_parent_span_id(const void* value, size_t size);
  ::std::string* mutable_parent_span_id();
  ::std::string* release_parent_span_id();
  void set_allocated_parent_span_id(::std::string* parent_span_id);

  // string name = 5;
  void clear_name();
  static const int kNameFieldNumber = 5;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  #if LANG_CXX11
  void set_name(::std::string&& value);
  #endif
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // .Status status = 15;
  bool has_status() const;
  void clear_status();
  static const int kStatusFieldNumber = 15;
  private:
  const ::Status& _internal_status() const;
  public:
  const ::Status& status() const;
  ::Status* release_status();
  ::Status* mutable_status();
  void set_allocated_status(::Status* status);

  // fixed64 start_time_unix_nano = 7;
  void clear_start_time_unix_nano();
  static const int kStartTimeUnixNanoFieldNumber = 7;
  ::google::protobuf::uint64 start_time_unix_nano() const;
  void set_start_time_unix_nano(::google::protobuf::uint64 value);

  // fixed64 end_time_unix_nano = 8;
  void clear_end_time_unix_nano();
  static const int kEndTimeUnixNanoFieldNumber = 8;
  ::google::protobuf::uint64 end_time_unix_nano() const;
  void set_end_time_unix_nano(::google::protobuf::uint64 value);

  // .Span.SpanKind kind = 6;
  void clear_kind();
  static const int kKindFieldNumber = 6;
  ::Span_SpanKind kind() const;
  void set_kind(::Span_SpanKind value);

  // uint32 dropped_attributes_count = 10;
  void clear_dropped_attributes_count();
  static const int kDroppedAttributesCountFieldNumber = 10;
  ::google::protobuf::uint32 dropped_attributes_count() const;
  void set_dropped_attributes_count(::google::protobuf::uint32 value);

  // uint32 dropped_events_count = 12;
  void clear_dropped_events_count();
  static const int kDroppedEventsCountFieldNumber = 12;
  ::google::protobuf::uint32 dropped_events_count() const;
  void set_dropped_events_count(::google::protobuf::uint32 value);

  // uint32 dropped_links_count = 14;
  void clear_dropped_links_count();
  static const int kDroppedLinksCountFieldNumber = 14;
  ::google::protobuf::uint32 dropped_links_count() const;
  void set_dropped_links_count(::google::protobuf::uint32 value);

  // fixed32 flags = 16;
  void clear_flags();
  static const int kFlagsFieldNumber = 16;
  ::google::protobuf::uint32 flags() const;
  void set_flags(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:Span)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::KeyValue > attributes_;
  ::google::protobuf::RepeatedPtrField< ::Span_Event > events_;
  ::google::protobuf::RepeatedPtrField< ::Span_Link > links_;
  ::google::protobuf::internal::ArenaStringPtr trace_id_;
  ::google::protobuf::internal::ArenaStringPtr span_id_;
  ::google::protobuf::internal::ArenaStringPtr trace_state_;
  ::google::protobuf::internal::ArenaStringPtr parent_span_id_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  ::Status* status_;
  ::google::protobuf::uint64 start_time_unix_nano_;
  ::google::protobuf::uint64 end_time_unix_nano_;
  int kind_;
  ::google::protobuf::uint32 dropped_attributes_count_;
  ::google::protobuf::uint32 dropped_events_count_;
  ::google::protobuf::uint32 dropped_links_count_;
  ::google::protobuf::uint32 flags_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_trace_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Status : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Status) */ {
 public:
  Status();
  virtual ~Status();

  Status(const Status& from);

  inline Status& operator=(const Status& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Status(Status&& from) noexcept
    : Status() {
    *this = ::std::move(from);
  }

  inline Status& operator=(Status&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Status& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Status* internal_default_instance() {
    return reinterpret_cast<const Status*>(
               &_Status_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  void Swap(Status* other);
  friend void swap(Status& a, Status& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Status* New() const final {
    return CreateMaybeMessage<Status>(NULL);
  }

  Status* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Status>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Status& from);
  void MergeFrom(const Status& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Status* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef Status_StatusCode StatusCode;
  static const StatusCode STATUS_CODE_UNSET =
    Status_StatusCode_STATUS_CODE_UNSET;
  static const StatusCode STATUS_CODE_OK =
    Status_StatusCode_STATUS_CODE_OK;
  static const StatusCode STATUS_CODE_ERROR =
    Status_StatusCode_STATUS_CODE_ERROR;
  static inline bool StatusCode_IsValid(int value) {
    return Status_StatusCode_IsValid(value);
  }
  static const StatusCode StatusCode_MIN =
    Status_StatusCode_StatusCode_MIN;
  static const StatusCode StatusCode_MAX =
    Status_StatusCode_StatusCode_MAX;
  static const int StatusCode_ARRAYSIZE =
    Status_StatusCode_StatusCode_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  StatusCode_descriptor() {
    return Status_StatusCode_descriptor();
  }
  static inline const ::std::string& StatusCode_Name(StatusCode value) {
    return Status_StatusCode_Name(value);
  }
  static inline bool StatusCode_Parse(const ::std::string& name,
      StatusCode* value) {
    return Status_StatusCode_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // string message = 2;
  void clear_message();
  static const int kMessageFieldNumber = 2;
  const ::std::string& message() const;
  void set_message(const ::std::string& value);
  #if LANG_CXX11
  void set_message(::std::string&& value);
  #endif
  void set_message(const char* value);
  void set_message(const char* value, size_t size);
  ::std::string* mutable_message();
  ::std::string* release_message();
  void set_allocated_message(::std::string* message);

  // .Status.StatusCode code = 3;
  void clear_code();
  static const int kCodeFieldNumber = 3;
  ::Status_StatusCode code() const;
  void set_code(::Status_StatusCode value);

  // @@protoc_insertion_point(class_scope:Status)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr message_;
  int code_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_trace_2eproto::TableStruct;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// AnyValue

// string string_value = 1;
inline bool AnyValue::has_string_value() const {
  return value_case() == kStringValue;
}
inline void AnyValue::set_has_string_value() {
  _oneof_case_[0] = kStringValue;
}
inline void AnyValue::clear_string_value() {
  if (has_string_value()) {
    value_.string_value_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    clear_has_value();
  }
}
inline const ::std::string& AnyValue::string_value() const {
  // @@protoc_insertion_point(field_get:AnyValue.string_value)
  if (has_string_value()) {
    return value_.string_value_.GetNoArena();
  }
  return *&::google::protobuf::internal::GetEmptyStringAlreadyInited();
}
inline void AnyValue::set_string_value(const ::std::string& value) {
  // @@protoc_insertion_point(field_set:AnyValue.string_value)
  if (!has_string_value()) {
    clear_value();
    set_has_string_value();
    value_.string_value_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  value_.string_value_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:AnyValue.string_value)
}
#if LANG_CXX11
inline void AnyValue::set_string_value(::std::string&& value) {
  // @@protoc_insertion_point(field_set:AnyValue.string_value)
  if (!has_string_value()) {
    clear_value();
    set_has_string_value();
    value_.string_value_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  value_.string_value_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:AnyValue.string_value)
}
#endif
inline void AnyValue::set_string_value(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  if (!has_string_value()) {
    clear_value();
    set_has_string_value();
    value_.string_value_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  value_.string_value_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(value));
  // @@protoc_insertion_point(field_set_char:AnyValue.string_value)
}
inline void AnyValue::set_string_value(const char* value, size_t size) {
  if (!has_string_value()) {
    clear_value();
    set_has_string_value();
    value_.string_value_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  value_.string_value_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:AnyValue.string_value)
}
inline ::std::string* AnyValue::mutable_string_value() {
  if (!has_string_value()) {
    clear_value();
    set_has_string_value();
    value_.string_value_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_mutable:AnyValue.string_value)
  return value_.string_value_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* AnyValue::release_string_value() {
  // @@protoc_insertion_point(field_release:AnyValue.string_value)
  if (has_string_value()) {
    clear_has_value();
    return value_.string_value_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  } else {
    return NULL;
  }
}
inline void AnyValue::set_allocated_string_value(::std::string* string_value) {
  if (!has_string_value()) {
    value_.string_value_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  clear_value();
  if (string_value != NULL) {
    set_has_string_value();
    value_.string_value_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), string_value);
  }
  // @@protoc_insertion_point(field_set_allocated:AnyValue.string_value)
}

// bool bool_value = 2;
inline bool AnyValue::has_bool_value() const {
  return value_case() == kBoolValue;
}
inline void AnyValue::set_has_bool_value() {
  _oneof_case_[0] = kBoolValue;
}
inline void AnyValue::clear_bool_value() {
  if (has_bool_value()) {
    value_.bool_value_ = false;
    clear_has_value();
  }
}
inline bool AnyValue::bool_value() const {
  // @@protoc_insertion_point(field_get:AnyValue.bool_value)
  if (has_bool_value()) {
    return value_.bool_value_;
  }
  return false;
}
inline void AnyValue::set_bool_value(bool value) {
  if (!has_bool_value()) {
    clear_value();
    set_has_bool_value();
  }
  value_.bool_value_ = value;
  // @@protoc_insertion_point(field_set:AnyValue.bool_value)
}

// int64 int_value = 3;
inline bool AnyValue::has_int_value() const {
  return value_case() == kIntValue;
}
inline void AnyValue::set_has_int_value() {
  _oneof_case_[0] = kIntValue;
}
inline void AnyValue::clear_int_value() {
  if (has_int_value()) {
    value_.int_value_ = GOOGLE_LONGLONG(0);
    clear_has_value();
  }
}
inline ::google::protobuf::int64 AnyValue::int_value() const {
  // @@protoc_insertion_point(field_get:AnyValue.int_value)
  if (has_int_value()) {
    return value_.int_value_;
  }
  return GOOGLE_LONGLONG(0);
}
inline void AnyValue::set_int_value(::google::protobuf::int64 value) {
  if (!has_int_value()) {
    clear_value();
    set_has_int_value();
  }
  value_.int_value_ = value;
  // @@protoc_insertion_point(field_set:AnyValue.int_value)
}

// double double_value = 4;
inline bool AnyValue::has_double_value() const {
  return value_case() == kDoubleValue;
}
inline void AnyValue::set_has_double_value() {
  _oneof_case_[0] = kDoubleValue;
}
inline void AnyValue::clear_double_value() {
  if (has_double_value()) {
    value_.double_value_ = 0;
    clear_has_value();
  }
}
inline double AnyValue::double_value() const {
  // @@protoc_insertion_point(field_get:AnyValue.double_value)
  if (has_double_value()) {
    return value_.double_value_;
  }
  return 0;
}
inline void AnyValue::set_double_value(double value) {
  if (!has_double_value()) {
    clear_value();
    set_has_double_value();
  }
  value_.double_value_ = value;
  // @@protoc_insertion_point(field_set:AnyValue.double_value)
}

// .ArrayValue array_value = 5;
inline bool AnyValue::has_array_value() const {
  return value_case() == kArrayValue;
}
inline void AnyValue::set_has_array_value() {
  _oneof_case_[0] = kArrayValue;
}
inline void AnyValue::clear_array_value() {
  if (has_array_value()) {
    delete value_.array_value_;
    clear_has_value();
  }
}
inline const ::ArrayValue& AnyValue::_internal_array_value() const {
  return *value_.array_value_;
}
inline ::ArrayValue* AnyValue::release_array_value() {
  // @@protoc_insertion_point(field_release:AnyValue.array_value)
  if (has_array_value()) {
    clear_has_value();
      ::ArrayValue* temp = value_.array_value_;
    value_.array_value_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::ArrayValue& AnyValue::array_value() const {
  // @@protoc_insertion_point(field_get:AnyValue.array_value)
  return has_array_value()
      ? *value_.array_value_
      : *reinterpret_cast< ::ArrayValue*>(&::_ArrayValue_default_instance_);
}
inline ::ArrayValue* AnyValue::mutable_array_value() {
  if (!has_array_value()) {
    clear_value();
    set_has_array_value();
    value_.array_value_ = CreateMaybeMessage< ::ArrayValue >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:AnyValue.array_value)
  return value_.array_value_;
}

// .KeyValueList kvlist_value = 6;
inline bool AnyValue::has_kvlist_value() const {
  return value_case() == kKvlistValue;
}
inline void AnyValue::set_has_kvlist_value() {
  _oneof_case_[0] = kKvlistValue;
}
inline void AnyValue::clear_kvlist_value() {
  if (has_kvlist_value()) {
    delete value_.kvlist_value_;
    clear_has_value();
  }
}
inline const ::KeyValueList& AnyValue::_internal_kvlist_value() const {
  return *value_.kvlist_value_;
}
inline ::KeyValueList* AnyValue::release_kvlist_value() {
  // @@protoc_insertion_point(field_release:AnyValue.kvlist_value)
  if (has_kvlist_value()) {
    clear_has_value();
      ::KeyValueList* temp = value_.kvlist_value_;
    value_.kvlist_value_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::KeyValueList& AnyValue::kvlist_value() const {
  // @@protoc_insertion_point(field_get:AnyValue.kvlist_value)
  return has_kvlist_value()
      ? *value_.kvlist_value_
      : *reinterpret_cast< ::KeyValueList*>(&::_KeyValueList_default_instance_);
}
inline ::KeyValueList* AnyValue::mutable_kvlist_value() {
  if (!has_kvlist_value()) {
    clear_value();
    set_has_kvlist_value();
    value_.kvlist_value_ = CreateMaybeMessage< ::KeyValueList >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:AnyValue.kvlist_value)
  return value_.kvlist_value_;
}

// bytes bytes_value = 7;
inline bool AnyValue::has_bytes_value() const {
  return value_case() == kBytesValue;
}
inline void AnyValue::set_has_bytes_value() {
  _oneof_case_[0] = kBytesValue;
}
inline void AnyValue::clear_bytes_value() {
  if (has_bytes_value()) {
    value_.bytes_value_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    clear_has_value();
  }
}
inline const ::std::string& AnyValue::bytes_value() const {
  // @@protoc_insertion_point(field_get:AnyValue.bytes_value)
  if (has_bytes_value()) {
    return value_.bytes_value_.GetNoArena();
  }
  return *&::google::protobuf::internal::GetEmptyStringAlreadyInited();
}
inline void AnyValue::set_bytes_value(const ::std::string& value) {
  // @@protoc_insertion_point(field_set:AnyValue.bytes_value)
  if (!has_bytes_value()) {
    clear_value();
    set_has_bytes_value();
    value_.bytes_value_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  value_.bytes_value_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:AnyValue.bytes_value)
}
#if LANG_CXX11
inline void AnyValue::set_bytes_value(::std::string&& value) {
  // @@protoc_insertion_point(field_set:AnyValue.bytes_value)
  if (!has_bytes_value()) {
    clear_value();
    set_has_bytes_value();
    value_.bytes_value_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  value_.bytes_value_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:AnyValue.bytes_value)
}
#endif
inline void AnyValue::set_bytes_value(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  if (!has_bytes_value()) {
    clear_value();
    set_has_bytes_value();
    value_.bytes_value_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  value_.bytes_value_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(value));
  // @@protoc_insertion_point(field_set_char:AnyValue.bytes_value)
}
inline void AnyValue::set_bytes_value(const void* value, size_t size) {
  if (!has_bytes_value()) {
    clear_value();
    set_has_bytes_value();
    value_.bytes_value_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  value_.bytes_value_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:AnyValue.bytes_value)
}
inline ::std::string* AnyValue::mutable_bytes_value() {
  if (!has_bytes_value()) {
    clear_value();
    set_has_bytes_value();
    value_.bytes_value_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_mutable:AnyValue.bytes_value)
  return value_.bytes_value_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* AnyValue::release_bytes_value() {
  // @@protoc_insertion_point(field_release:AnyValue.bytes_value)
  if (has_bytes_value()) {
    clear_has_value();
    return value_.bytes_value_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  } else {
    return NULL;
  }
}
inline void AnyValue::set_allocated_bytes_value(::std::string* bytes_value) {
  if (!has_bytes_value()) {
    value_.bytes_value_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  clear_value();
  if (bytes_value != NULL) {
    set_has_bytes_value();
    value_.bytes_value_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), bytes_value);
  }
  // @@protoc_insertion_point(field_set_allocated:AnyValue.bytes_value)
}

inline bool AnyValue::has_value() const {
  return value_case() != VALUE_NOT_SET;
}
inline void AnyValue::clear_has_value() {
  _oneof_case_[0] = VALUE_NOT_SET;
}
inline AnyValue::ValueCase AnyValue::value_case() const {
  return AnyValue::ValueCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// ArrayValue

// repeated .AnyValue values = 1;
inline int ArrayValue::values_size() const {
  return values_.size();
}
inline void ArrayValue::clear_values() {
  values_.Clear();
}
inline ::AnyValue* ArrayValue::mutable_values(int index) {
  // @@protoc_insertion_point(field_mutable:ArrayValue.values)
  return values_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::AnyValue >*
ArrayValue::mutable_values() {
  // @@protoc_insertion_point(field_mutable_list:ArrayValue.values)
  return &values_;
}
inline const ::AnyValue& ArrayValue::values(int index) const {
  // @@protoc_insertion_point(field_get:ArrayValue.values)
  return values_.Get(index);
}
inline ::AnyValue* ArrayValue::add_values() {
  // @@protoc_insertion_point(field_add:ArrayValue.values)
  return values_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::AnyValue >&
ArrayValue::values() const {
  // @@protoc_insertion_point(field_list:ArrayValue.values)
  return values_;
}

// -------------------------------------------------------------------

// KeyValueList

// repeated .KeyValue values = 1;
inline int KeyValueList::values_size() const {
  return values_.size();
}
inline void KeyValueList::clear_values() {
  values_.Clear();
}
inline ::KeyValue* KeyValueList::mutable_values(int index) {
  // @@protoc_insertion_point(field_mutable:KeyValueList.values)
  return values_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::KeyValue >*
KeyValueList::mutable_values() {
  // @@protoc_insertion_point(field_mutable_list:KeyValueList.values)
  return &values_;
}
inline const ::KeyValue& KeyValueList::values(int index) const {
  // @@protoc_insertion_point(field_get:KeyValueList.values)
  return values_.Get(index);
}
inline ::KeyValue* KeyValueList::add_values() {
  // @@protoc_insertion_point(field_add:KeyValueList.values)
  return values_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::KeyValue >&
KeyValueList::values() const {
  // @@protoc_insertion_point(field_list:KeyValueList.values)
  return values_;
}

// -------------------------------------------------------------------

// KeyValue

// string key = 1;
inline void KeyValue::clear_key() {
  key_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& KeyValue::key() const {
  // @@protoc_insertion_point(field_get:KeyValue.key)
  return key_.GetNoArena();
}
inline void KeyValue::set_key(const ::std::string& value) {
  
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:KeyValue.key)
}
#if LANG_CXX11
inline void KeyValue::set_key(::std::string&& value) {
  
  key_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:KeyValue.key)
}
#endif
inline void KeyValue::set_key(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:KeyValue.key)
}
inline void KeyValue::set_key(const char* value, size_t size) {
  
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:KeyValue.key)
}
inline ::std::string* KeyValue::mutable_key() {
  
  // @@protoc_insertion_point(field_mutable:KeyValue.key)
  return key_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* KeyValue::release_key() {
  // @@protoc_insertion_point(field_release:KeyValue.key)
  
  return key_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void KeyValue::set_allocated_key(::std::string* key) {
  if (key != NULL) {
    
  } else {
    
  }
  key_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), key);
  // @@protoc_insertion_point(field_set_allocated:KeyValue.key)
}

// .AnyValue value = 2;
inline bool KeyValue::has_value() const {
  return this != internal_default_instance() && value_ != NULL;
}
inline void KeyValue::clear_value() {
  if (GetArenaNoVirtual() == NULL && value_ != NULL) {
    delete value_;
  }
  value_ = NULL;
}
inline const ::AnyValue& KeyValue::_internal_value() const {
  return *value_;
}
inline const ::AnyValue& KeyValue::value() const {
  const ::AnyValue* p = value_;
  // @@protoc_insertion_point(field_get:KeyValue.value)
  return p != NULL ? *p : *reinterpret_cast<const ::AnyValue*>(
      &::_AnyValue_default_instance_);
}
inline ::AnyValue* KeyValue::release_value() {
  // @@protoc_insertion_point(field_release:KeyValue.value)
  
  ::AnyValue* temp = value_;
  value_ = NULL;
  return temp;
}
inline ::AnyValue* KeyValue::mutable_value() {
  
  if (value_ == NULL) {
    auto* p = CreateMaybeMessage<::AnyValue>(GetArenaNoVirtual());
    value_ = p;
  }
  // @@protoc_insertion_point(field_mutable:KeyValue.value)
  return value_;
}
inline void KeyValue::set_allocated_value(::AnyValue* value) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete value_;
  }
  if (value) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, value, submessage_arena);
    }
    
  } else {
    
  }
  value_ = value;
  // @@protoc_insertion_point(field_set_allocated:KeyValue.value)
}

// -------------------------------------------------------------------

// InstrumentationScope

// string name = 1;
inline void InstrumentationScope::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& InstrumentationScope::name() const {
  // @@protoc_insertion_point(field_get:InstrumentationScope.name)
  return name_.GetNoArena();
}
inline void InstrumentationScope::set_name(const ::std::string& value) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:InstrumentationScope.name)
}
#if LANG_CXX11
inline void InstrumentationScope::set_name(::std::string&& value) {
  
  name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:InstrumentationScope.name)
}
#endif
inline void InstrumentationScope::set_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:InstrumentationScope.name)
}
inline void InstrumentationScope::set_name(const char* value, size_t size) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:InstrumentationScope.name)
}
inline ::std::string* InstrumentationScope::mutable_name() {
  
  // @@protoc_insertion_point(field_mutable:InstrumentationScope.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* InstrumentationScope::release_name() {
  // @@protoc_insertion_point(field_release:InstrumentationScope.name)
  
  return name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void InstrumentationScope::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    
  } else {
    
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:InstrumentationScope.name)
}

// string version = 2;
inline void InstrumentationScope::clear_version() {
  version_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& InstrumentationScope::version() const {
  // @@protoc_insertion_point(field_get:InstrumentationScope.version)
  return version_.GetNoArena();
}
inline void InstrumentationScope::set_version(const ::std::string& value) {
  
  version_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:InstrumentationScope.version)
}
#if LANG_CXX11
inline void InstrumentationScope::set_version(::std::string&& value) {
  
  version_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:InstrumentationScope.version)
}
#endif
inline void InstrumentationScope::set_version(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  version_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:InstrumentationScope.version)
}
inline void InstrumentationScope::set_version(const char* value, size_t size) {
  
  version_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:InstrumentationScope.version)
}
inline ::std::string* InstrumentationScope::mutable_version() {
  
  // @@protoc_insertion_point(field_mutable:InstrumentationScope.version)
  return version_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* InstrumentationScope::release_version() {
  // @@protoc_insertion_point(field_release:InstrumentationScope.version)
  
  return version_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void InstrumentationScope::set_allocated_version(::std::string* version) {
  if (version != NULL) {
    
  } else {
    
  }
  version_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), version);
  // @@protoc_insertion_point(field_set_allocated:InstrumentationScope.version)
}

// repeated .KeyValue attributes = 3;
inline int InstrumentationScope::attributes_size() const {
  return attributes_.size();
}
inline void InstrumentationScope::clear_attributes() {
  attributes_.Clear();
}
inline ::KeyValue* InstrumentationScope::mutable_attributes(int index) {
  // @@protoc_insertion_point(field_mutable:InstrumentationScope.attributes)
  return attributes_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::KeyValue >*
InstrumentationScope::mutable_attributes() {
  // @@protoc_insertion_point(field_mutable_list:InstrumentationScope.attributes)
  return &attributes_;
}
inline const ::KeyValue& InstrumentationScope::attributes(int index) const {
  // @@protoc_insertion_point(field_get:InstrumentationScope.attributes)
  return attributes_.Get(index);
}
inline ::KeyValue* InstrumentationScope::add_attributes() {
  // @@protoc_insertion_point(field_add:InstrumentationScope.attributes)
  return attributes_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::KeyValue >&
InstrumentationScope::attributes() const {
  // @@protoc_insertion_point(field_list:InstrumentationScope.attributes)
  return attributes_;
}

// uint32 dropped_attributes_count = 4;
inline void InstrumentationScope::clear_dropped_attributes_count() {
  dropped_attributes_count_ = 0u;
}
inline ::google::protobuf::uint32 InstrumentationScope::dropped_attributes_count() const {
  // @@protoc_insertion_point(field_get:InstrumentationScope.dropped_attributes_count)
  return dropped_attributes_count_;
}
inline void InstrumentationScope::set_dropped_attributes_count(::google::protobuf::uint32 value) {
  
  dropped_attributes_count_ = value;
  // @@protoc_insertion_point(field_set:InstrumentationScope.dropped_attributes_count)
}

// -------------------------------------------------------------------

// Resource

// repeated .KeyValue attributes = 1;
inline int Resource::attributes_size() const {
  return attributes_.size();
}
inline void Resource::clear_attributes() {
  attributes_.Clear();
}
inline ::KeyValue* Resource::mutable_attributes(int index) {
  // @@protoc_insertion_point(field_mutable:Resource.attributes)
  return attributes_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::KeyValue >*
Resource::mutable_attributes() {
  // @@protoc_insertion_point(field_mutable_list:Resource.attributes)
  return &attributes_;
}
inline const ::KeyValue& Resource::attributes(int index) const {
  // @@protoc_insertion_point(field_get:Resource.attributes)
  return attributes_.Get(index);
}
inline ::KeyValue* Resource::add_attributes() {
  // @@protoc_insertion_point(field_add:Resource.attributes)
  return attributes_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::KeyValue >&
Resource::attributes() const {
  // @@protoc_insertion_point(field_list:Resource.attributes)
  return attributes_;
}

// uint32 dropped_attributes_count = 2;
inline void Resource::clear_dropped_attributes_count() {
  dropped_attributes_count_ = 0u;
}
inline ::google::protobuf::uint32 Resource::dropped_attributes_count() const {
  // @@protoc_insertion_point(field_get:Resource.dropped_attributes_count)
  return dropped_attributes_count_;
}
inline void Resource::set_dropped_attributes_count(::google::protobuf::uint32 value) {
  
  dropped_attributes_count_ = value;
  // @@protoc_insertion_point(field_set:Resource.dropped_attributes_count)
}

// -------------------------------------------------------------------

// TracesData

// repeated .ResourceSpans resource_spans = 1;
inline int TracesData::resource_spans_size() const {
  return resource_spans_.size();
}
inline void TracesData::clear_resource_spans() {
  resource_spans_.Clear();
}
inline ::ResourceSpans* TracesData::mutable_resource_spans(int index) {
  // @@protoc_insertion_point(field_mutable:TracesData.resource_spans)
  return resource_spans_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::ResourceSpans >*
TracesData::mutable_resource_spans() {
  // @@protoc_insertion_point(field_mutable_list:TracesData.resource_spans)
  return &resource_spans_;
}
inline const ::ResourceSpans& TracesData::resource_spans(int index) const {
  // @@protoc_insertion_point(field_get:TracesData.resource_spans)
  return resource_spans_.Get(index);
}
inline ::ResourceSpans* TracesData::add_resource_spans() {
  // @@protoc_insertion_point(field_add:TracesData.resource_spans)
  return resource_spans_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::ResourceSpans >&
TracesData::resource_spans() const {
  // @@protoc_insertion_point(field_list:TracesData.resource_spans)
  return resource_spans_;
}

// -------------------------------------------------------------------

// ResourceSpans

// .Resource resource = 1;
inline bool ResourceSpans::has_resource() const {
  return this != internal_default_instance() && resource_ != NULL;
}
inline void ResourceSpans::clear_resource() {
  if (GetArenaNoVirtual() == NULL && resource_ != NULL) {
    delete resource_;
  }
  resource_ = NULL;
}
inline const ::Resource& ResourceSpans::_internal_resource() const {
  return *resource_;
}
inline const ::Resource& ResourceSpans::resource() const {
  const ::Resource* p = resource_;
  // @@protoc_insertion_point(field_get:ResourceSpans.resource)
  return p != NULL ? *p : *reinterpret_cast<const ::Resource*>(
      &::_Resource_default_instance_);
}
inline ::Resource* ResourceSpans::release_resource() {
  // @@protoc_insertion_point(field_release:ResourceSpans.resource)
  
  ::Resource* temp = resource_;
  resource_ = NULL;
  return temp;
}
inline ::Resource* ResourceSpans::mutable_resource() {
  
  if (resource_ == NULL) {
    auto* p = CreateMaybeMessage<::Resource>(GetArenaNoVirtual());
    resource_ = p;
  }
  // @@protoc_insertion_point(field_mutable:ResourceSpans.resource)
  return resource_;
}
inline void ResourceSpans::set_allocated_resource(::Resource* resource) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete resource_;
  }
  if (resource) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      resource = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, resource, submessage_arena);
    }
    
  } else {
    
  }
  resource_ = resource;
  // @@protoc_insertion_point(field_set_allocated:ResourceSpans.resource)
}

// repeated .ScopeSpans scope_spans = 2;
inline int ResourceSpans::scope_spans_size() const {
  return scope_spans_.size();
}
inline void ResourceSpans::clear_scope_spans() {
  scope_spans_.Clear();
}
inline ::ScopeSpans* ResourceSpans::mutable_scope_spans(int index) {
  // @@protoc_insertion_point(field_mutable:ResourceSpans.scope_spans)
  return scope_spans_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::ScopeSpans >*
ResourceSpans::mutable_scope_spans() {
  // @@protoc_insertion_point(field_mutable_list:ResourceSpans.scope_spans)
  return &scope_spans_;
}
inline const ::ScopeSpans& ResourceSpans::scope_spans(int index) const {
  // @@protoc_insertion_point(field_get:ResourceSpans.scope_spans)
  return scope_spans_.Get(index);
}
inline ::ScopeSpans* ResourceSpans::add_scope_spans() {
  // @@protoc_insertion_point(field_add:ResourceSpans.scope_spans)
  return scope_spans_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::ScopeSpans >&
ResourceSpans::scope_spans() const {
  // @@protoc_insertion_point(field_list:ResourceSpans.scope_spans)
  return scope_spans_;
}

// string schema_url = 3;
inline void ResourceSpans::clear_schema_url() {
  schema_url_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& ResourceSpans::schema_url() const {
  // @@protoc_insertion_point(field_get:ResourceSpans.schema_url)
  return schema_url_.GetNoArena();
}
inline void ResourceSpans::set_schema_url(const ::std::string& value) {
  
  schema_url_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:ResourceSpans.schema_url)
}
#if LANG_CXX11
inline void ResourceSpans::set_schema_url(::std::string&& value) {
  
  schema_url_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:ResourceSpans.schema_url)
}
#endif
inline void ResourceSpans::set_schema_url(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  schema_url_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:ResourceSpans.schema_url)
}
inline void ResourceSpans::set_schema_url(const char* value, size_t size) {
  
  schema_url_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:ResourceSpans.schema_url)
}
inline ::std::string* ResourceSpans::mutable_schema_url() {
  
  // @@protoc_insertion_point(field_mutable:ResourceSpans.schema_url)
  return schema_url_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ResourceSpans::release_schema_url() {
  // @@protoc_insertion_point(field_release:ResourceSpans.schema_url)
  
  return schema_url_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ResourceSpans::set_allocated_schema_url(::std::string* schema_url) {
  if (schema_url != NULL) {
    
  } else {
    
  }
  schema_url_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), schema_url);
  // @@protoc_insertion_point(field_set_allocated:ResourceSpans.schema_url)
}

// -------------------------------------------------------------------

// ScopeSpans

// .InstrumentationScope scope = 1;
inline bool ScopeSpans::has_scope() const {
  return this != internal_default_instance() && scope_ != NULL;
}
inline void ScopeSpans::clear_scope() {
  if (GetArenaNoVirtual() == NULL && scope_ != NULL) {
    delete scope_;
  }
  scope_ = NULL;
}
inline const ::InstrumentationScope& ScopeSpans::_internal_scope() const {
  return *scope_;
}
inline const ::InstrumentationScope& ScopeSpans::scope() const {
  const ::InstrumentationScope* p = scope_;
  // @@protoc_insertion_point(field_get:ScopeSpans.scope)
  return p != NULL ? *p : *reinterpret_cast<const ::InstrumentationScope*>(
      &::_InstrumentationScope_default_instance_);
}
inline ::InstrumentationScope* ScopeSpans::release_scope() {
  // @@protoc_insertion_point(field_release:ScopeSpans.scope)
  
  ::InstrumentationScope* temp = scope_;
  scope_ = NULL;
  return temp;
}
inline ::InstrumentationScope* ScopeSpans::mutable_scope() {
  
  if (scope_ == NULL) {
    auto* p = CreateMaybeMessage<::InstrumentationScope>(GetArenaNoVirtual());
    scope_ = p;
  }
  // @@protoc_insertion_point(field_mutable:ScopeSpans.scope)
  return scope_;
}
inline void ScopeSpans::set_allocated_scope(::InstrumentationScope* scope) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete scope_;
  }
  if (scope) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      scope = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, scope, submessage_arena);
    }
    
  } else {
    
  }
  scope_ = scope;
  // @@protoc_insertion_point(field_set_allocated:ScopeSpans.scope)
}

// repeated .Span spans = 2;
inline int ScopeSpans::spans_size() const {
  return spans_.size();
}
inline void ScopeSpans::clear_spans() {
  spans_.Clear();
}
inline ::Span* ScopeSpans::mutable_spans(int index) {
  // @@protoc_insertion_point(field_mutable:ScopeSpans.spans)
  return spans_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::Span >*
ScopeSpans::mutable_spans() {
  // @@protoc_insertion_point(field_mutable_list:ScopeSpans.spans)
  return &spans_;
}
inline const ::Span& ScopeSpans::spans(int index) const {
  // @@protoc_insertion_point(field_get:ScopeSpans.spans)
  return spans_.Get(index);
}
inline ::Span* ScopeSpans::add_spans() {
  // @@protoc_insertion_point(field_add:ScopeSpans.spans)
  return spans_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Span >&
ScopeSpans::spans() const {
  // @@protoc_insertion_point(field_list:ScopeSpans.spans)
  return spans_;
}

// string schema_url = 3;
inline void ScopeSpans::clear_schema_url() {
  schema_url_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& ScopeSpans::schema_url() const {
  // @@protoc_insertion_point(field_get:ScopeSpans.schema_url)
  return schema_url_.GetNoArena();
}
inline void ScopeSpans::set_schema_url(const ::std::string& value) {
  
  schema_url_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:ScopeSpans.schema_url)
}
#if LANG_CXX11
inline void ScopeSpans::set_schema_url(::std::string&& value) {
  
  schema_url_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:ScopeSpans.schema_url)
}
#endif
inline void ScopeSpans::set_schema_url(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  schema_url_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:ScopeSpans.schema_url)
}
inline void ScopeSpans::set_schema_url(const char* value, size_t size) {
  
  schema_url_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:ScopeSpans.schema_url)
}
inline ::std::string* ScopeSpans::mutable_schema_url() {
  
  // @@protoc_insertion_point(field_mutable:ScopeSpans.schema_url)
  return schema_url_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ScopeSpans::release_schema_url() {
  // @@protoc_insertion_point(field_release:ScopeSpans.schema_url)
  
  return schema_url_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ScopeSpans::set_allocated_schema_url(::std::string* schema_url) {
  if (schema_url != NULL) {
    
  } else {
    
  }
  schema_url_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), schema_url);
  // @@protoc_insertion_point(field_set_allocated:ScopeSpans.schema_url)
}

// -------------------------------------------------------------------

// Span_Event

// fixed64 time_unix_nano = 1;
inline void Span_Event::clear_time_unix_nano() {
  time_unix_nano_ = GOOGLE_ULONGLONG(0);
}
inline ::google::protobuf::uint64 Span_Event::time_unix_nano() const {
  // @@protoc_insertion_point(field_get:Span.Event.time_unix_nano)
  return time_unix_nano_;
}
inline void Span_Event::set_time_unix_nano(::google::protobuf::uint64 value) {
  
  time_unix_nano_ = value;
  // @@protoc_insertion_point(field_set:Span.Event.time_unix_nano)
}

// string name = 2;
inline void Span_Event::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Span_Event::name() const {
  // @@protoc_insertion_point(field_get:Span.Event.name)
  return name_.GetNoArena();
}
inline void Span_Event::set_name(const ::std::string& value) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:Span.Event.name)
}
#if LANG_CXX11
inline void Span_Event::set_name(::std::string&& value) {
  
  name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:Span.Event.name)
}
#endif
inline void Span_Event::set_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:Span.Event.name)
}
inline void Span_Event::set_name(const char* value, size_t size) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:Span.Event.name)
}
inline ::std::string* Span_Event::mutable_name() {
  
  // @@protoc_insertion_point(field_mutable:Span.Event.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Span_Event::release_name() {
  // @@protoc_insertion_point(field_release:Span.Event.name)
  
  return name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Span_Event::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    
  } else {
    
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:Span.Event.name)
}

// repeated .KeyValue attributes = 3;
inline int Span_Event::attributes_size() const {
  return attributes_.size();
}
inline void Span_Event::clear_attributes() {
  attributes_.Clear();
}
inline ::KeyValue* Span_Event::mutable_attributes(int index) {
  // @@protoc_insertion_point(field_mutable:Span.Event.attributes)
  return attributes_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::KeyValue >*
Span_Event::mutable_attributes() {
  // @@protoc_insertion_point(field_mutable_list:Span.Event.attributes)
  return &attributes_;
}
inline const ::KeyValue& Span_Event::attributes(int index) const {
  // @@protoc_insertion_point(field_get:Span.Event.attributes)
  return attributes_.Get(index);
}
inline ::KeyValue* Span_Event::add_attributes() {
  // @@protoc_insertion_point(field_add:Span.Event.attributes)
  return attributes_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::KeyValue >&
Span_Event::attributes() const {
  // @@protoc_insertion_point(field_list:Span.Event.attributes)
  return attributes_;
}

// uint32 dropped_attributes_count = 4;
inline void Span_Event::clear_dropped_attributes_count() {
  dropped_attributes_count_ = 0u;
}
inline ::google::protobuf::uint32 Span_Event::dropped_attributes_count() const {
  // @@protoc_insertion_point(field_get:Span.Event.dropped_attributes_count)
  return dropped_attributes_count_;
}
inline void Span_Event::set_dropped_attributes_count(::google::protobuf::uint32 value) {
  
  dropped_attributes_count_ = value;
  // @@protoc_insertion_point(field_set:Span.Event.dropped_attributes_count)
}

// -------------------------------------------------------------------

// Span_Link

// bytes trace_id = 1;
inline void Span_Link::clear_trace_id() {
  trace_id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Span_Link::trace_id() const {
  // @@protoc_insertion_point(field_get:Span.Link.trace_id)
  return trace_id_.GetNoArena();
}
inline void Span_Link::set_trace_id(const ::std::string& value) {
  
  trace_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:Span.Link.trace_id)
}
#if LANG_CXX11
inline void Span_Link::set_trace_id(::std::string&& value) {
  
  trace_id_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:Span.Link.trace_id)
}
#endif
inline void Span_Link::set_trace_id(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  trace_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:Span.Link.trace_id)
}
inline void Span_Link::set_trace_id(const void* value, size_t size) {
  
  trace_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:Span.Link.trace_id)
}
inline ::std::string* Span_Link::mutable_trace_id() {
  
  // @@protoc_insertion_point(field_mutable:Span.Link.trace_id)
  return trace_id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Span_Link::release_trace_id() {
  // @@protoc_insertion_point(field_release:Span.Link.trace_id)
  
  return trace_id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Span_Link::set_allocated_trace_id(::std::string* trace_id) {
  if (trace_id != NULL) {
    
  } else {
    
  }
  trace_id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), trace_id);
  // @@protoc_insertion_point(field_set_allocated:Span.Link.trace_id)
}

// bytes span_id = 2;
inline void Span_Link::clear_span_id() {
  span_id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Span_Link::span_id() const {
  // @@protoc_insertion_point(field_get:Span.Link.span_id)
  return span_id_.GetNoArena();
}
inline void Span_Link::set_span_id(const ::std::string& value) {
  
  span_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:Span.Link.span_id)
}
#if LANG_CXX11
inline void Span_Link::set_span_id(::std::string&& value) {
  
  span_id_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:Span.Link.span_id)
}
#endif
inline void Span_Link::set_span_id(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  span_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:Span.Link.span_id)
}
inline void Span_Link::set_span_id(const void* value, size_t size) {
  
  span_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:Span.Link.span_id)
}
inline ::std::string* Span_Link::mutable_span_id() {
  
  // @@protoc_insertion_point(field_mutable:Span.Link.span_id)
  return span_id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Span_Link::release_span_id() {
  // @@protoc_insertion_point(field_release:Span.Link.span_id)
  
  return span_id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Span_Link::set_allocated_span_id(::std::string* span_id) {
  if (span_id != NULL) {
    
  } else {
    
  }
  span_id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), span_id);
  // @@protoc_insertion_point(field_set_allocated:Span.Link.span_id)
}

// string trace_state = 3;
inline void Span_Link::clear_trace_state() {
  trace_state_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Span_Link::trace_state() const {
  // @@protoc_insertion_point(field_get:Span.Link.trace_state)
  return trace_state_.GetNoArena();
}
inline void Span_Link::set_trace_state(const ::std::string& value) {
  
  trace_state_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:Span.Link.trace_state)
}
#if LANG_CXX11
inline void Span_Link::set_trace_state(::std::string&& value) {
  
  trace_state_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:Span.Link.trace_state)
}
#endif
inline void Span_Link::set_trace_state(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  trace_state_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:Span.Link.trace_state)
}
inline void Span_Link::set_trace_state(const char* value, size_t size) {
  
  trace_state_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:Span.Link.trace_state)
}
inline ::std::string* Span_Link::mutable_trace_state() {
  
  // @@protoc_insertion_point(field_mutable:Span.Link.trace_state)
  return trace_state_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Span_Link::release_trace_state() {
  // @@protoc_insertion_point(field_release:Span.Link.trace_state)
  
  return trace_state_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Span_Link::set_allocated_trace_state(::std::string* trace_state) {
  if (trace_state != NULL) {
    
  } else {
    
  }
  trace_state_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), trace_state);
  // @@protoc_insertion_point(field_set_allocated:Span.Link.trace_state)
}

// repeated .KeyValue attributes = 4;
inline int Span_Link::attributes_size() const {
  return attributes_.size();
}
inline void Span_Link::clear_attributes() {
  attributes_.Clear();
}
inline ::KeyValue* Span_Link::mutable_attributes(int index) {
  // @@protoc_insertion_point(field_mutable:Span.Link.attributes)
  return attributes_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::KeyValue >*
Span_Link::mutable_attributes() {
  // @@protoc_insertion_point(field_mutable_list:Span.Link.attributes)
  return &attributes_;
}
inline const ::KeyValue& Span_Link::attributes(int index) const {
  // @@protoc_insertion_point(field_get:Span.Link.attributes)
  return attributes_.Get(index);
}
inline ::KeyValue* Span_Link::add_attributes() {
  // @@protoc_insertion_point(field_add:Span.Link.attributes)
  return attributes_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::KeyValue >&
Span_Link::attributes() const {
  // @@protoc_insertion_point(field_list:Span.Link.attributes)
  return attributes_;
}

// uint32 dropped_attributes_count = 5;
inline void Span_Link::clear_dropped_attributes_count() {
  dropped_attributes_count_ = 0u;
}
inline ::google::protobuf::uint32 Span_Link::dropped_attributes_count() const {
  // @@protoc_insertion_point(field_get:Span.Link.dropped_attributes_count)
  return dropped_attributes_count_;
}
inline void Span_Link::set_dropped_attributes_count(::google::protobuf::uint32 value) {
  
  dropped_attributes_count_ = value;
  // @@protoc_insertion_point(field_set:Span.Link.dropped_attributes_count)
}

// fixed32 flags = 6;
inline void Span_Link::clear_flags() {
  flags_ = 0u;
}
inline ::google::protobuf::uint32 Span_Link::flags() const {
  // @@protoc_insertion_point(field_get:Span.Link.flags)
  return flags_;
}
inline void Span_Link::set_flags(::google::protobuf::uint32 value) {
  
  flags_ = value;
  // @@protoc_insertion_point(field_set:Span.Link.flags)
}

// -------------------------------------------------------------------

// Span

// bytes trace_id = 1;
inline void Span::clear_trace_id() {
  trace_id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Span::trace_id() const {
  // @@protoc_insertion_point(field_get:Span.trace_id)
  return trace_id_.GetNoArena();
}
inline void Span::set_trace_id(const ::std::string& value) {
  
  trace_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:Span.trace_id)
}
#if LANG_CXX11
inline void Span::set_trace_id(::std::string&& value) {
  
  trace_id_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:Span.trace_id)
}
#endif
inline void Span::set_trace_id(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  trace_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:Span.trace_id)
}
inline void Span::set_trace_id(const void* value, size_t size) {
  
  trace_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:Span.trace_id)
}
inline ::std::string* Span::mutable_trace_id() {
  
  // @@protoc_insertion_point(field_mutable:Span.trace_id)
  return trace_id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Span::release_trace_id() {
  // @@protoc_insertion_point(field_release:Span.trace_id)
  
  return trace_id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Span::set_allocated_trace_id(::std::string* trace_id) {
  if (trace_id != NULL) {
    
  } else {
    
  }
  trace_id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), trace_id);
  // @@protoc_insertion_point(field_set_allocated:Span.trace_id)
}

// bytes span_id = 2;
inline void Span::clear_span_id() {
  span_id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Span::span_id() const {
  // @@protoc_insertion_point(field_get:Span.span_id)
  return span_id_.GetNoArena();
}
inline void Span::set_span_id(const ::std::string& value) {
  
  span_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:Span.span_id)
}
#if LANG_CXX11
inline void Span::set_span_id(::std::string&& value) {
  
  span_id_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:Span.span_id)
}
#endif
inline void Span::set_span_id(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  span_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:Span.span_id)
}
inline void Span::set_span_id(const void* value, size_t size) {
  
  span_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:Span.span_id)
}
inline ::std::string* Span::mutable_span_id() {
  
  // @@protoc_insertion_point(field_mutable:Span.span_id)
  return span_id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Span::release_span_id() {
  // @@protoc_insertion_point(field_release:Span.span_id)
  
  return span_id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Span::set_allocated_span_id(::std::string* span_id) {
  if (span_id != NULL) {
    
  } else {
    
  }
  span_id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), span_id);
  // @@protoc_insertion_point(field_set_allocated:Span.span_id)
}

// string trace_state = 3;
inline void Span::clear_trace_state() {
  trace_state_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Span::trace_state() const {
  // @@protoc_insertion_point(field_get:Span.trace_state)
  return trace_state_.GetNoArena();
}
inline void Span::set_trace_state(const ::std::string& value) {
  
  trace_state_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:Span.trace_state)
}
#if LANG_CXX11
inline void Span::set_trace_state(::std::string&& value) {
  
  trace_state_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:Span.trace_state)
}
#endif
inline void Span::set_trace_state(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  trace_state_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:Span.trace_state)
}
inline void Span::set_trace_state(const char* value, size_t size) {
  
  trace_state_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:Span.trace_state)
}
inline ::std::string* Span::mutable_trace_state() {
  
  // @@protoc_insertion_point(field_mutable:Span.trace_state)
  return trace_state_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Span::release_trace_state() {
  // @@protoc_insertion_point(field_release:Span.trace_state)
  
  return trace_state_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Span::set_allocated_trace_state(::std::string* trace_state) {
  if (trace_state != NULL) {
    
  } else {
    
  }
  trace_state_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), trace_state);
  // @@protoc_insertion_point(field_set_allocated:Span.trace_state)
}

// bytes parent_span_id = 4;
inline void Span::clear_parent_span_id() {
  parent_span_id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Span::parent_span_id() const {
  // @@protoc_insertion_point(field_get:Span.parent_span_id)
  return parent_span_id_.GetNoArena();
}
inline void Span::set_parent_span_id(const ::std::string& value) {
  
  parent_span_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:Span.parent_span_id)
}
#if LANG_CXX11
inline void Span::set_parent_span_id(::std::string&& value) {
  
  parent_span_id_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:Span.parent_span_id)
}
#endif
inline void Span::set_parent_span_id(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  parent_span_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:Span.parent_span_id)
}
inline void Span::set_parent_span_id(const void* value, size_t size) {
  
  parent_span_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:Span.parent_span_id)
}
inline ::std::string* Span::mutable_parent_span_id() {
  
  // @@protoc_insertion_point(field_mutable:Span.parent_span_id)
  return parent_span_id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Span::release_parent_span_id() {
  // @@protoc_insertion_point(field_release:Span.parent_span_id)
  
  return parent_span_id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Span::set_allocated_parent_span_id(::std::string* parent_span_id) {
  if (parent_span_id != NULL) {
    
  } else {
    
  }
  parent_span_id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), parent_span_id);
  // @@protoc_insertion_point(field_set_allocated:Span.parent_span_id)
}

// fixed32 flags = 16;
inline void Span::clear_flags() {
  flags_ = 0u;
}
inline ::google::protobuf::uint32 Span::flags() const {
  // @@protoc_insertion_point(field_get:Span.flags)
  return flags_;
}
inline void Span::set_flags(::google::protobuf::uint32 value) {
  
  flags_ = value;
  // @@protoc_insertion_point(field_set:Span.flags)
}

// string name = 5;
inline void Span::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Span::name() const {
  // @@protoc_insertion_point(field_get:Span.name)
  return name_.GetNoArena();
}
inline void Span::set_name(const ::std::string& value) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:Span.name)
}
#if LANG_CXX11
inline void Span::set_name(::std::string&& value) {
  
  name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:Span.name)
}
#endif
inline void Span::set_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:Span.name)
}
inline void Span::set_name(const char* value, size_t size) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:Span.name)
}
inline ::std::string* Span::mutable_name() {
  
  // @@protoc_insertion_point(field_mutable:Span.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Span::release_name() {
  // @@protoc_insertion_point(field_release:Span.name)
  
  return name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Span::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    
  } else {
    
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:Span.name)
}

// .Span.SpanKind kind = 6;
inline void Span::clear_kind() {
  kind_ = 0;
}
inline ::Span_SpanKind Span::kind() const {
  // @@protoc_insertion_point(field_get:Span.kind)
  return static_cast< ::Span_SpanKind >(kind_);
}
inline void Span::set_kind(::Span_SpanKind value) {
  
  kind_ = value;
  // @@protoc_insertion_point(field_set:Span.kind)
}

// fixed64 start_time_unix_nano = 7;
inline void Span::clear_start_time_unix_nano() {
  start_time_unix_nano_ = GOOGLE_ULONGLONG(0);
}
inline ::google::protobuf::uint64 Span::start_time_unix_nano() const {
  // @@protoc_insertion_point(field_get:Span.start_time_unix_nano)
  return start_time_unix_nano_;
}
inline void Span::set_start_time_unix_nano(::google::protobuf::uint64 value) {
  
  start_time_unix_nano_ = value;
  // @@protoc_insertion_point(field_set:Span.start_time_unix_nano)
}

// fixed64 end_time_unix_nano = 8;
inline void Span::clear_end_time_unix_nano() {
  end_time_unix_nano_ = GOOGLE_ULONGLONG(0);
}
inline ::google::protobuf::uint64 Span::end_time_unix_nano() const {
  // @@protoc_insertion_point(field_get:Span.end_time_unix_nano)
  return end_time_unix_nano_;
}
inline void Span::set_end_time_unix_nano(::google::protobuf::uint64 value) {
  
  end_time_unix_nano_ = value;
  // @@protoc_insertion_point(field_set:Span.end_time_unix_nano)
}

// repeated .KeyValue attributes = 9;
inline int Span::attributes_size() const {
  return attributes_.size();
}
inline void Span::clear_attributes() {
  attributes_.Clear();
}
inline ::KeyValue* Span::mutable_attributes(int index) {
  // @@protoc_insertion_point(field_mutable:Span.attributes)
  return attributes_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::KeyValue >*
Span::mutable_attributes() {
  // @@protoc_insertion_point(field_mutable_list:Span.attributes)
  return &attributes_;
}
inline const ::KeyValue& Span::attributes(int index) const {
  // @@protoc_insertion_point(field_get:Span.attributes)
  return attributes_.Get(index);
}
inline ::KeyValue* Span::add_attributes() {
  // @@protoc_insertion_point(field_add:Span.attributes)
  return attributes_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::KeyValue >&
Span::attributes() const {
  // @@protoc_insertion_point(field_list:Span.attributes)
  return attributes_;
}

// uint32 dropped_attributes_count = 10;
inline void Span::clear_dropped_attributes_count() {
  dropped_attributes_count_ = 0u;
}
inline ::google::protobuf::uint32 Span::dropped_attributes_count() const {
  // @@protoc_insertion_point(field_get:Span.dropped_attributes_count)
  return dropped_attributes_count_;
}
inline void Span::set_dropped_attributes_count(::google::protobuf::uint32 value) {
  
  dropped_attributes_count_ = value;
  // @@protoc_insertion_point(field_set:Span.dropped_attributes_count)
}

// repeated .Span.Event events = 11;
inline int Span::events_size() const {
  return events_.size();
}
inline void Span::clear_events() {
  events_.Clear();
}
inline ::Span_Event* Span::mutable_events(int index) {
  // @@protoc_insertion_point(field_mutable:Span.events)
  return events_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::Span_Event >*
Span::mutable_events() {
  // @@protoc_insertion_point(field_mutable_list:Span.events)
  return &events_;
}
inline const ::Span_Event& Span::events(int index) const {
  // @@protoc_insertion_point(field_get:Span.events)
  return events_.Get(index);
}
inline ::Span_Event* Span::add_events() {
  // @@protoc_insertion_point(field_add:Span.events)
  return events_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Span_Event >&
Span::events() const {
  // @@protoc_insertion_point(field_list:Span.events)
  return events_;
}

// uint32 dropped_events_count = 12;
inline void Span::clear_dropped_events_count() {
  dropped_events_count_ = 0u;
}
inline ::google::protobuf::uint32 Span::dropped_events_count() const {
  // @@protoc_insertion_point(field_get:Span.dropped_events_count)
  return dropped_events_count_;
}
inline void Span::set_dropped_events_count(::google::protobuf::uint32 value) {
  
  dropped_events_count_ = value;
  // @@protoc_insertion_point(field_set:Span.dropped_events_count)
}

// repeated .Span.Link links = 13;
inline int Span::links_size() const {
  return links_.size();
}
inline void Span::clear_links() {
  links_.Clear();
}
inline ::Span_Link* Span::mutable_links(int index) {
  // @@protoc_insertion_point(field_mutable:Span.links)
  return links_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::Span_Link >*
Span::mutable_links() {
  // @@protoc_insertion_point(field_mutable_list:Span.links)
  return &links_;
}
inline const ::Span_Link& Span::links(int index) const {
  // @@protoc_insertion_point(field_get:Span.links)
  return links_.Get(index);
}
inline ::Span_Link* Span::add_links() {
  // @@protoc_insertion_point(field_add:Span.links)
  return links_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Span_Link >&
Span::links() const {
  // @@protoc_insertion_point(field_list:Span.links)
  return links_;
}

// uint32 dropped_links_count = 14;
inline void Span::clear_dropped_links_count() {
  dropped_links_count_ = 0u;
}
inline ::google::protobuf::uint32 Span::dropped_links_count() const {
  // @@protoc_insertion_point(field_get:Span.dropped_links_count)
  return dropped_links_count_;
}
inline void Span::set_dropped_links_count(::google::protobuf::uint32 value) {
  
  dropped_links_count_ = value;
  // @@protoc_insertion_point(field_set:Span.dropped_links_count)
}

// .Status status = 15;
inline bool Span::has_status() const {
  return this != internal_default_instance() && status_ != NULL;
}
inline void Span::clear_status() {
  if (GetArenaNoVirtual() == NULL && status_ != NULL) {
    delete status_;
  }
  status_ = NULL;
}
inline const ::Status& Span::_internal_status() const {
  return *status_;
}
inline const ::Status& Span::status() const {
  const ::Status* p = status_;
  // @@protoc_insertion_point(field_get:Span.status)
  return p != NULL ? *p : *reinterpret_cast<const ::Status*>(
      &::_Status_default_instance_);
}
inline ::Status* Span::release_status() {
  // @@protoc_insertion_point(field_release:Span.status)
  
  ::Status* temp = status_;
  status_ = NULL;
  return temp;
}
inline ::Status* Span::mutable_status() {
  
  if (status_ == NULL) {
    auto* p = CreateMaybeMessage<::Status>(GetArenaNoVirtual());
    status_ = p;
  }
  // @@protoc_insertion_point(field_mutable:Span.status)
  return status_;
}
inline void Span::set_allocated_status(::Status* status) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete status_;
  }
  if (status) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      status = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, status, submessage_arena);
    }
    
  } else {
    
  }
  status_ = status;
  // @@protoc_insertion_point(field_set_allocated:Span.status)
}

// -------------------------------------------------------------------

// Status

// string message = 2;
inline void Status::clear_message() {
  message_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Status::message() const {
  // @@protoc_insertion_point(field_get:Status.message)
  return message_.GetNoArena();
}
inline void Status::set_message(const ::std::string& value) {
  
  message_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:Status.message)
}
#if LANG_CXX11
inline void Status::set_message(::std::string&& value) {
  
  message_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:Status.message)
}
#endif
inline void Status::set_message(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  message_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:Status.message)
}
inline void Status::set_message(const char* value, size_t size) {
  
  message_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:Status.message)
}
inline ::std::string* Status::mutable_message() {
  
  // @@protoc_insertion_point(field_mutable:Status.message)
  return message_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Status::release_message() {
  // @@protoc_insertion_point(field_release:Status.message)
  
  return message_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Status::set_allocated_message(::std::string* message) {
  if (message != NULL) {
    
  } else {
    
  }
  message_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), message);
  // @@protoc_insertion_point(field_set_allocated:Status.message)
}

// .Status.StatusCode code = 3;
inline void Status::clear_code() {
  code_ = 0;
}
inline ::Status_StatusCode Status::code() const {
  // @@protoc_insertion_point(field_get:Status.code)
  return static_cast< ::Status_StatusCode >(code_);
}
inline void Status::set_code(::Status_StatusCode value) {
  
  code_ = value;
  // @@protoc_insertion_point(field_set:Status.code)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)


namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::Span_SpanKind> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Span_SpanKind>() {
  return ::Span_SpanKind_descriptor();
}
template <> struct is_proto_enum< ::Status_StatusCode> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Status_StatusCode>() {
  return ::Status_StatusCode_descriptor();
}
template <> struct is_proto_enum< ::SpanFlags> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::SpanFlags>() {
  return ::SpanFlags_descriptor();
}

}  // namespace protobuf
}  // namespace google

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_INCLUDED_trace_2eproto
